<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Ruby Critic - Home</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- StyleSheets -->
    <link href="../../assets/stylesheets/bootstrap.min.css" media="screen, projection, print" rel="stylesheet" type="text/css">
    <link href="../../assets/stylesheets/font-awesome.min.css" media="screen, projection, print" rel="stylesheet" type="text/css">
    <link href="../../assets/stylesheets/prettify.custom_theme.css" media="screen, projection, print" rel="stylesheet" type="text/css">
    <link href="../../assets/stylesheets/application.css" media="screen, projection, print" rel="stylesheet" type="text/css">
  </head>

  <body>
    <header class="navbar navbar-default navbar-fixed-top">
      <a href="#menu-toggle" class="btn btn-default hidden-lg visible-sm-* hidden-md visible-xs-* pull-left" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a>
      <a href="../../overview.html"><img src="../../assets/images/logo.png" alt="Ruby Critic Logo" title="Ruby Critic Logo" width="55"><span class="logo">RUBYCRITIC</span></a>
      
    </header>
    <div id="wrapper">
      <!-- Sidebar -->
      <aside id="sidebar-wrapper">
        <ul class="sidebar-nav">
          <li class="sidebar-item">
            <a href="../../overview.html" class="project-nav-item overview-nav"><i class="fa fa-dashboard"></i>Overview</a>
          </li>
          <li class="sidebar-item">
            <a href="../../code_index.html" class="project-nav-item code-index-nav"><i class="fa fa-code"></i>Code</a>
          </li>
          <li class="sidebar-item">
            <a href="../../smells_index.html" class="project-nav-item smells-index-nav"><i class="fa fa-warning"></i>Smells</a>
          </li>
        </ul>
      </aside>
      <!-- /#sidebar-wrapper -->
      <div id="page-content-wrapper">
        <div class="container-fluid">
          <div class="row">
  <!--Page Title -->
  <div class="Page_Title">
    <div class="file-time">
      <span class="committed-at">
        
          Updated <time class='js-timeago' datetime='2019-04-18 06:45:20 +0100'>2019-04-18 06:45:20 +0100</time>
        
      </span>
    </div>
    <div>
      <h3><small>spec/models /</small> petition_spec.rb</h3>
    </div>
  </div>
  <!--End Page Title -->
  <div class="Content_Wrapper">
    <!-- code detail -->
    <div class="code-top-detail clearfix row">
      <div class="col-md-8">
        <div class="row">
          <div class="col-md-1">
            <div class="rating f big">
              F
            </div>
          </div>
          <div class="code-statistics col-md-11">
            <div class="col-md-3">
              <div><span class="metric">2937</span><small> lines of codes</small></div>
              <div><span class="metric">0</span><small> methods</small></div>
            </div>
            <div class="col-md-3">
              <div><span class="metric">N/A</span><small> complexity/method</small></div>
              <div><span class="metric">159</span><small> churn</small></div>
            </div>
            <div class="col-md-3">
              <div><span class="metric">7267.27</span><small> complexity</small></div>
              <div><span class="metric">4110</span><small> duplications</small></div>
            </div>
          </div>
        </div>
      </div>
      <div class="col-md-4">
        <div class="code-tabs">
          <ul class="nav nav-pills right-to-left">
            <li><a href="#" id="toggle-code" class="toggle-button button">code</a></li>
            <li class="active">
              <a href="#" id="toggle-smells" class="toggle-button button">
                81
                smells
              </a>
            </li>
          </ul>
        </div>
      </div>
    </div>

    <code class="prettyprint linenums lang-ruby file-code js-file-code">require &#39;rails_helper&#39;
require_relative &#39;taggable_examples&#39;

RSpec.describe Petition, type: :model do
  context &quot;defaults&quot; do
    it &quot;has pending as default state&quot; do
      p = Petition.new
      expect(p.state).to eq(&quot;pending&quot;)
    end

    it &quot;generates sponsor token&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 4 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L11" class="js-smell-location">0</a>                  <a href="signature_spec.html#L25" class="js-smell-location">1</a>                  <a href="signature_spec.html#L35" class="js-smell-location">2</a>                  <a href="signature_spec.html#L40" class="js-smell-location">3</a>                  </div>  </li></ol>
      p = FactoryBot.create(:petition, :sponsor_token =&gt; nil)
      expect(p.sponsor_token).not_to be_nil
    end
  end

  describe &quot;associations&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe#associations has a flog score of 33</span>          </div>  </li></ol>
    it { is_expected.to have_one(:debate_outcome).dependent(:destroy) }
    it { is_expected.to have_one(:government_response).dependent(:destroy) }

    it { is_expected.to have_many(:emails).dependent(:destroy) }
    it { is_expected.to have_many(:invalidations) }
  end

  describe &quot;callbacks&quot; do
    context &quot;when creating a petition&quot; do
      let(:now) { Time.current }

      before do
        Site.update_all(last_petition_created_at: nil)
      end

      it &quot;updates the site&#39;s last_petition_created_at column&quot; do
        expect {
          FactoryBot.create(:petition)
        }.to change {
          Site.last_petition_created_at
        }.from(nil).to(be_within(1.second).of(now))
      end
    end
  end

  context &quot;validations&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>VeryHighComplexity</b></a>        </span>      </div>      <span>context#validations has a flog score of 86</span>          </div>  </li></ol>
    it { is_expected.to validate_presence_of(:action).with_message(/must be completed/) }
    it { is_expected.to validate_presence_of(:background).with_message(/must be completed/) }
    it { is_expected.to validate_presence_of(:creator).with_message(/must be completed/) }

    it { is_expected.to have_db_column(:action).of_type(:string).with_options(limit: 255, null: false) }
    it { is_expected.to have_db_column(:background).of_type(:string).with_options(limit: 300, null: true) }
    it { is_expected.to have_db_column(:additional_details).of_type(:text).with_options(null: true) }

    it &quot;should validate the length of :action to within 80 characters&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L52" class="js-smell-location">0</a>                  <a href="petition_spec.html#L57" class="js-smell-location">1</a>                  <a href="petition_spec.html#L62" class="js-smell-location">2</a>                  </div>  </li></ol>
      expect(FactoryBot.build(:petition, :action =&gt; &#39;x&#39; * 80)).to be_valid
      expect(FactoryBot.build(:petition, :action =&gt; &#39;x&#39; * 81)).not_to be_valid
    end

    it &quot;should validate the length of :background to within 300 characters&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L52" class="js-smell-location">0</a>                  <a href="petition_spec.html#L57" class="js-smell-location">1</a>                  <a href="petition_spec.html#L62" class="js-smell-location">2</a>                  </div>  </li></ol>
      expect(FactoryBot.build(:petition, :background =&gt; &#39;x&#39; * 300)).to be_valid
      expect(FactoryBot.build(:petition, :background =&gt; &#39;x&#39; * 301)).not_to be_valid
    end

    it &quot;should validate the length of :additional_details to within 800 characters&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L52" class="js-smell-location">0</a>                  <a href="petition_spec.html#L57" class="js-smell-location">1</a>                  <a href="petition_spec.html#L62" class="js-smell-location">2</a>                  </div>  </li></ol>
      expect(FactoryBot.build(:petition, :additional_details =&gt; &#39;x&#39; * 800)).to be_valid
      expect(FactoryBot.build(:petition, :additional_details =&gt; &#39;x&#39; * 801)).not_to be_valid
    end

    it &quot;does not allow a blank state&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L67" class="js-smell-location">0</a>                  <a href="petition_spec.html#L74" class="js-smell-location">1</a>                  </div>  </li></ol>
      petition = FactoryBot.build(:petition, state: &#39;&#39;)

      expect(petition).not_to be_valid
      expect(petition.errors[:state]).not_to be_empty
    end

    it &quot;does not allow an unknown state&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L67" class="js-smell-location">0</a>                  <a href="petition_spec.html#L74" class="js-smell-location">1</a>                  </div>  </li></ol>
      petition = FactoryBot.build(:petition, state: &#39;unknown&#39;)

      expect(petition).not_to be_valid
      expect(petition.errors[:state]).not_to be_empty
    end

    %w(pending validated sponsored flagged open rejected hidden).each do |state|
      it &quot;allows state: #{state}&quot; do
        petition = FactoryBot.build(:&quot;#{state}_petition&quot;)

        expect(petition).to be_valid
        expect(petition.state).to eq(state)
        expect(petition.errors[:state]).to be_empty
      end
    end

    context &quot;when state is open&quot; do
      let(:petition) { FactoryBot.build(:open_petition, open_at: nil, closed_at: nil) }

      it &quot;checks petition is invalid if no open_at date&quot; do
        expect(petition).not_to be_valid
        expect(petition.errors[:open_at]).not_to be_empty
      end

      it &quot;checks petition is valid if there is an open_at date&quot; do
        petition.open_at = Time.current
        expect(petition).to be_valid
      end
    end
  end

  context &quot;scopes&quot; do
    describe &quot;trending&quot; do
      before(:each) do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>context(scopes)::describe(trending)::before#each has a flog score of 30</span>          </div>  </li></ol>
        11.times do |count|<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L109" class="js-smell-location">0</a>                  <a href="petition_spec.html#L129" class="js-smell-location">1</a>                  </div>  </li></ol>
          petition = FactoryBot.create(:open_petition, action: &quot;petition ##{count+1}&quot;, last_signed_at: Time.current)
          count.times { FactoryBot.create(:validated_signature, petition: petition) }
        end

        @petition_with_old_signatures = FactoryBot.create(:open_petition, action: &quot;petition out of range&quot;, last_signed_at: 2.hours.ago)
        @petition_with_old_signatures.signatures.first.update_attribute(:validated_at, 2.hours.ago)
      end

      it &quot;returns petitions trending for the last hour&quot; do
        expect(Petition.trending.map(&amp;:id).include?(@petition_with_old_signatures.id)).to be_falsey
      end

      it &quot;returns the signature count for the last hour as an additional attribute&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>context(scopes)::describe(trending)::it#returns the signature count for the last hour as an additional attribute has a flog score of 26</span>          </div>  </li></ol>
        expect(Petition.trending.first.signature_count_in_period).to eq(11)
        expect(Petition.trending.last.signature_count_in_period).to eq(9)
      end

      it &quot;limits the result to 3 petitions&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>context(scopes)::describe(trending)::it#limits the result to 3 petitions has a flog score of 26</span>          </div>  </li></ol>
        # 13 petitions signed in the last hour
        2.times do |count|<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L109" class="js-smell-location">0</a>                  <a href="petition_spec.html#L129" class="js-smell-location">1</a>                  </div>  </li></ol>
          petition = FactoryBot.create(:open_petition, action: &quot;petition ##{count+1}&quot;, last_signed_at: Time.current)
          count.times { FactoryBot.create(:validated_signature, petition: petition) }
        end

        expect(Petition.trending.to_a.size).to eq(3)
      end

      it &quot;excludes petitions that are not open&quot; do
        petition = FactoryBot.create(:validated_petition)
        20.times{ FactoryBot.create(:validated_signature, petition: petition) }

        expect(Petition.trending.to_a).not_to include(petition)
      end

      it &quot;excludes signatures that have been invalidated&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>context(scopes)::describe(trending)::it#excludes signatures that have been invalidated has a flog score of 33</span>          </div>  </li></ol>
        petition = Petition.trending.first
        signature = FactoryBot.create(:validated_signature, petition: petition)

        expect(Petition.trending.first.signature_count_in_period).to eq(12)

        signature.invalidate!
        expect(Petition.trending.first.signature_count_in_period).to eq(11)
      end
    end

    context &quot;threshold&quot; do
      before :each do
        @p1 = FactoryBot.create(:open_petition, signature_count: Site.threshold_for_debate)
        @p2 = FactoryBot.create(:open_petition, signature_count: Site.threshold_for_debate + 1)
        @p3 = FactoryBot.create(:open_petition, signature_count: Site.threshold_for_debate - 1)
        @p4 = FactoryBot.create(:open_petition, signature_count: Site.threshold_for_debate * 2)
      end

      it &quot;returns 3 petitions over the threshold&quot; do
        petitions = Petition.threshold
        expect(petitions.size).to eq(3)
        expect(petitions).to include(@p1, @p2, @p4)
      end
    end

    context &quot;for_state&quot; do
      before :each do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>context(scopes)::context(for_state)::before#each has a flog score of 26</span>          </div>  </li></ol>
        @p1 = FactoryBot.create(:petition, :state =&gt; Petition::PENDING_STATE)
        @p2 = FactoryBot.create(:petition, :state =&gt; Petition::VALIDATED_STATE)
        @p3 = FactoryBot.create(:petition, :state =&gt; Petition::PENDING_STATE)
        @p4 = FactoryBot.create(:open_petition, :closed_at =&gt; 1.day.from_now)
        @p5 = FactoryBot.create(:petition, :state =&gt; Petition::HIDDEN_STATE)
        @p6 = FactoryBot.create(:closed_petition, :closed_at =&gt; 1.day.ago)
        @p7 = FactoryBot.create(:petition, :state =&gt; Petition::SPONSORED_STATE)
        @p8 = FactoryBot.create(:petition, :state =&gt; Petition::FLAGGED_STATE)
      end

      it &quot;returns 2 pending petitions&quot; do
        petitions = Petition.for_state(Petition::PENDING_STATE)
        expect(petitions.size).to eq(2)
        expect(petitions).to include(@p1, @p3)
      end

      it &quot;returns 1 validated, sponsored, flagged, open, closed and hidden petitions&quot; do
        [[Petition::VALIDATED_STATE, @p2], [Petition::OPEN_STATE, @p4],
         [Petition::HIDDEN_STATE, @p5], [Petition::CLOSED_STATE, @p6],
         [Petition::SPONSORED_STATE, @p7], [Petition::FLAGGED_STATE, @p8]].each do |state_and_petition|
          petitions = Petition.for_state(state_and_petition[0])
          expect(petitions.size).to eq(1)
          expect(petitions).to eq([state_and_petition[1]])
        end
      end
    end

    context &quot;visible&quot; do
      before :each do
        @hidden_petition_1 = FactoryBot.create(:petition, :state =&gt; Petition::PENDING_STATE)
        @hidden_petition_2 = FactoryBot.create(:petition, :state =&gt; Petition::VALIDATED_STATE)
        @hidden_petition_3 = FactoryBot.create(:petition, :state =&gt; Petition::HIDDEN_STATE)
        @hidden_petition_4 = FactoryBot.create(:petition, :state =&gt; Petition::SPONSORED_STATE)
        @hidden_petition_5 = FactoryBot.create(:petition, :state =&gt; Petition::FLAGGED_STATE)
        @visible_petition_1 = FactoryBot.create(:open_petition)
        @visible_petition_2 = FactoryBot.create(:rejected_petition)
        @visible_petition_3 = FactoryBot.create(:open_petition, :closed_at =&gt; 1.day.ago)
      end

      it &quot;returns only visible petitions&quot; do
        expect(Petition.visible.size).to eq(3)
        expect(Petition.visible).to include(@visible_petition_1, @visible_petition_2, @visible_petition_3)
      end
    end

    context &quot;current&quot; do
      let!(:petition) { FactoryBot.create(:open_petition) }
      let!(:other_petition) { FactoryBot.create(:open_petition, created_at: 2.week.ago) }
      let!(:closed_petition) { FactoryBot.create(:closed_petition) }
      let!(:rejected_petition) { FactoryBot.create(:rejected_petition) }

      it &quot;doesn&#39;t include closed petitions&quot; do
        expect(described_class.current).not_to include(closed_petition)
      end

      it &quot;doesn&#39;t include rejected petitions&quot; do
        expect(described_class.current).not_to include(closed_petition)
      end

      it &quot;returns open petitions, newest first&quot; do
        expect(described_class.current).to match_array([petition, other_petition])
      end
    end

    context &quot;not_hidden&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 4 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L236" class="js-smell-location">0</a>                  <a href="petition_spec.html#L245" class="js-smell-location">1</a>                  <a href="petition_spec.html#L253" class="js-smell-location">2</a>                  <a href="petition_spec.html#L261" class="js-smell-location">3</a>                  </div>  </li></ol>
      let!(:petition) { FactoryBot.create(:hidden_petition) }

      it &quot;returns only petitions that are not hidden&quot; do
        expect(Petition.not_hidden).not_to include(petition)
      end
    end

    context &quot;awaiting_response&quot; do
      context &quot;when the petition has not reached the response threshold&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 4 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L236" class="js-smell-location">0</a>                  <a href="petition_spec.html#L245" class="js-smell-location">1</a>                  <a href="petition_spec.html#L253" class="js-smell-location">2</a>                  <a href="petition_spec.html#L261" class="js-smell-location">3</a>                  </div>  </li></ol>
        let(:petition) { FactoryBot.create(:open_petition) }

        it &quot;is not included in the list&quot; do
          expect(Petition.awaiting_response).not_to include(petition)
        end
      end

      context &quot;when a petition has reached the response threshold&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 4 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L236" class="js-smell-location">0</a>                  <a href="petition_spec.html#L245" class="js-smell-location">1</a>                  <a href="petition_spec.html#L253" class="js-smell-location">2</a>                  <a href="petition_spec.html#L261" class="js-smell-location">3</a>                  </div>  </li></ol>
        let(:petition) { FactoryBot.create(:awaiting_petition) }

        it &quot;is included in the list&quot; do
          expect(Petition.awaiting_response).to include(petition)
        end
      end

      context &quot;when a petition has a response&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 4 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L236" class="js-smell-location">0</a>                  <a href="petition_spec.html#L245" class="js-smell-location">1</a>                  <a href="petition_spec.html#L253" class="js-smell-location">2</a>                  <a href="petition_spec.html#L261" class="js-smell-location">3</a>                  </div>  </li></ol>
        let(:petition) { FactoryBot.create(:responded_petition) }

        it &quot;is not included in the list&quot; do
          expect(Petition.awaiting_response).not_to include(petition)
        end
      end
    end

    context &quot;with_response&quot; do
      before do
        @p1 = FactoryBot.create(:responded_petition)
        @p2 = FactoryBot.create(:open_petition)
        @p3 = FactoryBot.create(:responded_petition)
        @p4 = FactoryBot.create(:open_petition)
      end

      it &quot;returns only the petitions have a government response timestamp&quot; do
        expect(Petition.with_response).to match_array([@p1, @p3])
      end
    end

    context &quot;with_debate_outcome&quot; do
      before do
        @p1 = FactoryBot.create(:debated_petition)
        @p2 = FactoryBot.create(:open_petition)
        @p3 = FactoryBot.create(:debated_petition)
        @p4 = FactoryBot.create(:closed_petition)
        @p5 = FactoryBot.create(:rejected_petition)
        @p6 = FactoryBot.create(:sponsored_petition)
        @p7 = FactoryBot.create(:pending_petition)
        @p8 = FactoryBot.create(:validated_petition)
      end

      it &quot;returns only the petitions which have a debate outcome&quot; do
        expect(Petition.with_debate_outcome).to match_array([@p1, @p3])
      end
    end

    context &quot;with_debated_outcome&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>context(scopes)::context#with_debated_outcome has a flog score of 27</span>          </div>  </li></ol>
      before do
        @p1 = FactoryBot.create(:debated_petition)
        @p2 = FactoryBot.create(:open_petition)
        @p3 = FactoryBot.create(:not_debated_petition)
        @p4 = FactoryBot.create(:closed_petition)
        @p5 = FactoryBot.create(:rejected_petition)
        @p6 = FactoryBot.create(:sponsored_petition)
        @p7 = FactoryBot.create(:pending_petition)
        @p8 = FactoryBot.create(:validated_petition)
        @p9 = FactoryBot.create(:open_petition, scheduled_debate_date: 1.day.ago, debate_state: &#39;debated&#39;)
      end

      it &quot;returns only the petitions which have a positive debate outcome&quot; do
        expect(Petition.with_debated_outcome).to match_array([@p1])
      end
    end

    context &quot;awaiting_debate&quot; do
      before do
        @p1 = FactoryBot.create(:open_petition)
        @p2 = FactoryBot.create(:awaiting_debate_petition)
        @p3 = FactoryBot.create(:scheduled_debate_petition, scheduled_debate_date: 2.days.from_now)
        @p4 = FactoryBot.create(:scheduled_debate_petition, scheduled_debate_date: 2.days.ago)
      end

      it &quot;doesn&#39;t return petitions that have aren&#39;t eligible&quot; do
        expect(Petition.awaiting_debate).not_to include(@p1)
      end

      it &quot;returns petitions that have reached the debate threshold&quot; do
        expect(Petition.awaiting_debate).to include(@p2)
      end

      it &quot;returns petitions that have a scheduled debate date in the future&quot; do
        expect(Petition.awaiting_debate).to include(@p3)
      end

      it &quot;doesn&#39;t return petitions that have been debated&quot; do
        expect(Petition.awaiting_debate).not_to include(@p4)
      end
    end

    context &quot;by_most_recent_moderation_threshold_reached&quot; do
      let!(:p1) { FactoryBot.create(:sponsored_petition, moderation_threshold_reached_at: 2.days.ago) }
      let!(:p2) { FactoryBot.create(:sponsored_petition, moderation_threshold_reached_at: 1.day.ago) }

      it &quot;returns the petitions in the correct order&quot; do
        expect(Petition.by_most_recent_moderation_threshold_reached.to_a).to eq([p2, p1])
      end
    end

    context &quot;by_most_relevant_debate_date&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>context(scopes)::context#by_most_relevant_debate_date has a flog score of 29</span>          </div>  </li></ol>
      before do
        @p1 = FactoryBot.create(:awaiting_debate_petition, debate_threshold_reached_at: 2.weeks.ago)
        @p2 = FactoryBot.create(:awaiting_debate_petition, debate_threshold_reached_at: 4.weeks.ago)
        @p3 = FactoryBot.create(:awaiting_debate_petition, scheduled_debate_date: 4.days.from_now)
        @p4 = FactoryBot.create(:awaiting_debate_petition, scheduled_debate_date: 2.days.from_now)
      end

      it &quot;returns the petitions in the correct order&quot; do
        expect(Petition.by_most_relevant_debate_date.to_a).to eq([@p4, @p3, @p2, @p1])
      end
    end

    context &quot;debated&quot; do
      before do
        @p1 = FactoryBot.create(:open_petition)
        @p2 = FactoryBot.create(:open_petition, scheduled_debate_date: 2.days.from_now)
        @p3 = FactoryBot.create(:awaiting_debate_petition)
        @p4 = FactoryBot.create(:not_debated_petition)
        @p5 = FactoryBot.create(:debated_petition)
      end

      it &quot;doesn&#39;t return petitions that have aren&#39;t eligible&quot; do
        expect(Petition.debated).not_to include(@p1)
      end

      it &quot;doesn&#39;t return petitions that have a scheduled debate date&quot; do
        expect(Petition.debated).not_to include(@p2)
      end

      it &quot;doesn&#39;t return petitions that have reached the debate threshold&quot; do
        expect(Petition.debated).not_to include(@p3)
      end

      it &quot;doesn&#39;t return petitions that have been rejected for a debate&quot; do
        expect(Petition.debated).not_to include(@p4)
      end

      it &quot;returns petitions that have been debated&quot; do
        expect(Petition.debated).to include(@p5)
      end
    end

    context &quot;not_debated&quot; do
      before do
        @p1 = FactoryBot.create(:open_petition)
        @p2 = FactoryBot.create(:awaiting_debate_petition)
        @p3 = FactoryBot.create(:awaiting_debate_petition, scheduled_debate_date: 2.days.from_now)
        @p4 = FactoryBot.create(:awaiting_debate_petition, scheduled_debate_date: 2.days.ago)
        @p5 = FactoryBot.create(:not_debated_petition)
      end

      it &quot;doesn&#39;t return petitions that have aren&#39;t eligible&quot; do
        expect(Petition.not_debated).not_to include(@p1)
      end

      it &quot;doesn&#39;t return petitions that have reached the debate threshold&quot; do
        expect(Petition.not_debated).not_to include(@p2)
      end

      it &quot;doesn&#39;t return petitions that have a scheduled debate date in the future&quot; do
        expect(Petition.not_debated).not_to include(@p3)
      end

      it &quot;doesn&#39;t return petitions that have been debated&quot; do
        expect(Petition.not_debated).not_to include(@p4)
      end

      it &quot;returns petitions that have been rejected for a debate&quot; do
        expect(Petition.not_debated).to include(@p5)
      end
    end

    context &quot;awaiting_debate_date&quot; do
      before do
        @p1 = FactoryBot.create(:open_petition)
        @p2 = FactoryBot.create(:awaiting_debate_petition)
        @p3 = FactoryBot.create(:debated_petition)
      end

      it &quot;returns only petitions that reached the debate threshold&quot; do
        expect(Petition.awaiting_debate_date).to include(@p2)
      end

      it &quot;doesn&#39;t include petitions that has the debate date&quot; do
        expect(Petition.awaiting_debate_date).not_to include(@p3)
      end
    end

    context &quot;selectable&quot; do
      before :each do
        @non_selectable_petition_1 = FactoryBot.create(:petition, :state =&gt; Petition::PENDING_STATE)
        @non_selectable_petition_2 = FactoryBot.create(:petition, :state =&gt; Petition::VALIDATED_STATE)
        @non_selectable_petition_3 = FactoryBot.create(:petition, :state =&gt; Petition::SPONSORED_STATE)

        @selectable_petition_1 = FactoryBot.create(:open_petition)
        @selectable_petition_2 = FactoryBot.create(:rejected_petition)
        @selectable_petition_3 = FactoryBot.create(:closed_petition, :closed_at =&gt; 1.day.ago)
        @selectable_petition_4 = FactoryBot.create(:petition, :state =&gt; Petition::HIDDEN_STATE)
      end

      it &quot;returns only selectable petitions&quot; do
        expect(Petition.selectable.size).to eq(4)
        expect(Petition.selectable).to include(@selectable_petition_1, @selectable_petition_2, @selectable_petition_3, @selectable_petition_4)
      end
    end

    context &quot;stoppable&quot; do
      let!(:open_petition) { FactoryBot.create(:open_petition) }
      let!(:closed_petition) { FactoryBot.create(:open_petition) }
      let!(:rejected_petition) { FactoryBot.create(:rejected_petition) }
      let!(:hidden_petition) { FactoryBot.create(:hidden_petition) }

      let!(:stoppable_1) { FactoryBot.create(:pending_petition) }
      let!(:stoppable_2) { FactoryBot.create(:validated_petition) }
      let!(:stoppable_3) { FactoryBot.create(:sponsored_petition) }
      let!(:stoppable_4) { FactoryBot.create(:flagged_petition) }

      let(:stoppable_petitions) { [stoppable_1, stoppable_2, stoppable_3, stoppable_4] }

      it &quot;returns only stoppable petitions&quot; do
        expect(Petition.stoppable).to include(*stoppable_petitions)
      end
    end

    context &#39;in_debate_queue&#39; do
      let!(:petition_1) { FactoryBot.create(:open_petition, debate_threshold_reached_at: 1.day.ago) }
      let!(:petition_2) { FactoryBot.create(:open_petition, debate_threshold_reached_at: nil) }
      let!(:petition_3) { FactoryBot.create(:open_petition, debate_threshold_reached_at: nil, scheduled_debate_date: 3.days.from_now) }
      let!(:petition_4) { FactoryBot.create(:open_petition, debate_threshold_reached_at: nil, scheduled_debate_date: nil) }

      subject { described_class.in_debate_queue }

      it &#39;includes petitions that have reached the debate threshold&#39; do
        expect(subject).to include(petition_1)
        expect(subject).not_to include(petition_2)
      end

      it &#39;includes petitions that have not reached the debate threshold if they have been scheduled for debate&#39; do
        expect(subject).to include(petition_3)
        expect(subject).not_to include(petition_4)
      end
    end

    describe &#39;.popular_in_constituency&#39; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L496" class="js-smell-location">0</a>                  <a href="petition_spec.html#L556" class="js-smell-location">1</a>                  </div>  </li></ol>
      let!(:petition_1) { FactoryBot.create(:open_petition, signature_count: 10) }
      let!(:petition_2) { FactoryBot.create(:open_petition, signature_count: 20) }
      let!(:petition_3) { FactoryBot.create(:open_petition, signature_count: 30) }
      let!(:petition_4) { FactoryBot.create(:open_petition, signature_count: 40) }

      let!(:constituency_1) { FactoryBot.generate(:constituency_id) }
      let!(:constituency_2) { FactoryBot.generate(:constituency_id) }

      let!(:petition_1_journal_1) { FactoryBot.create(:constituency_petition_journal, petition: petition_1, constituency_id: constituency_1, signature_count: 6) }
      let!(:petition_1_journal_2) { FactoryBot.create(:constituency_petition_journal, petition: petition_1, constituency_id: constituency_2, signature_count: 4) }
      let!(:petition_2_journal_2) { FactoryBot.create(:constituency_petition_journal, petition: petition_2, constituency_id: constituency_2, signature_count: 20) }
      let!(:petition_3_journal_1) { FactoryBot.create(:constituency_petition_journal, petition: petition_3, constituency_id: constituency_1, signature_count: 30) }
      let!(:petition_4_journal_1) { FactoryBot.create(:constituency_petition_journal, petition: petition_4, constituency_id: constituency_1, signature_count: 0) }
      let!(:petition_4_journal_2) { FactoryBot.create(:constituency_petition_journal, petition: petition_4, constituency_id: constituency_2, signature_count: 40) }

      it &#39;excludes petitions that have no journal for the supplied constituency_id&#39; do
        popular = Petition.popular_in_constituency(constituency_1, 4)
        expect(popular).not_to include(petition_2)
      end

      it &#39;excludes petitions that have a journal with 0 votes for the supplied constituency_id&#39; do
        popular = Petition.popular_in_constituency(constituency_1, 4)
        expect(popular).not_to include(petition_4)
      end

      it &#39;excludes closed petitions with signatures from the supplied constituency_id&#39; do
        petition_1.update_columns(state: &#39;closed&#39;, closed_at: 3.days.ago)
        popular = Petition.popular_in_constituency(constituency_1, 4)
        expect(popular).not_to include(petition_1)
      end

      it &#39;excludes rejected petitions with signatures from the supplied constituency_id&#39; do
        petition_1.update_column(:state, Petition::REJECTED_STATE)
        popular = Petition.popular_in_constituency(constituency_1, 4)
        expect(popular).not_to include(petition_1)
      end

      it &#39;excludes hidden petitions with signatures from the supplied constituency_id&#39; do
        petition_1.update_column(:state, Petition::HIDDEN_STATE)
        popular = Petition.popular_in_constituency(constituency_1, 4)
        expect(popular).not_to include(petition_1)
      end

      it &#39;includes open petitions with signatures from the supplied constituency_id ordered by the count of signatures&#39; do
        popular = Petition.popular_in_constituency(constituency_1, 2)
        expect(popular).to eq [petition_3, petition_1]
      end

      it &#39;adds the constituency_signature_count attribute to the retrieved petitions&#39; do
        most_popular = Petition.popular_in_constituency(constituency_1, 1).first
        expect(most_popular).to respond_to :constituency_signature_count
        expect(most_popular.constituency_signature_count).to eq 30
      end

      it &#39;returns a scope&#39; do
        expect(Petition.popular_in_constituency(constituency_1, 1)).to be_an ActiveRecord::Relation
      end
    end

    describe &#39;.all_popular_in_constituency&#39; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L496" class="js-smell-location">0</a>                  <a href="petition_spec.html#L556" class="js-smell-location">1</a>                  </div>  </li></ol>
      let!(:petition_1) { FactoryBot.create(:open_petition, signature_count: 10) }
      let!(:petition_2) { FactoryBot.create(:open_petition, signature_count: 20) }
      let!(:petition_3) { FactoryBot.create(:open_petition, signature_count: 30) }
      let!(:petition_4) { FactoryBot.create(:open_petition, signature_count: 40) }

      let!(:constituency_1) { FactoryBot.generate(:constituency_id) }
      let!(:constituency_2) { FactoryBot.generate(:constituency_id) }

      let!(:petition_1_journal_1) { FactoryBot.create(:constituency_petition_journal, petition: petition_1, constituency_id: constituency_1, signature_count: 6) }
      let!(:petition_1_journal_2) { FactoryBot.create(:constituency_petition_journal, petition: petition_1, constituency_id: constituency_2, signature_count: 4) }
      let!(:petition_2_journal_2) { FactoryBot.create(:constituency_petition_journal, petition: petition_2, constituency_id: constituency_2, signature_count: 20) }
      let!(:petition_3_journal_1) { FactoryBot.create(:constituency_petition_journal, petition: petition_3, constituency_id: constituency_1, signature_count: 30) }
      let!(:petition_4_journal_1) { FactoryBot.create(:constituency_petition_journal, petition: petition_4, constituency_id: constituency_1, signature_count: 0) }
      let!(:petition_4_journal_2) { FactoryBot.create(:constituency_petition_journal, petition: petition_4, constituency_id: constituency_2, signature_count: 40) }

      it &#39;excludes petitions that have no journal for the supplied constituency_id&#39; do
        popular = Petition.all_popular_in_constituency(constituency_1, 4)
        expect(popular).not_to include(petition_2)
      end

      it &#39;excludes petitions that have a journal with 0 votes for the supplied constituency_id&#39; do
        popular = Petition.all_popular_in_constituency(constituency_1, 4)
        expect(popular).not_to include(petition_4)
      end

      it &#39;includes closed petitions with signatures from the supplied constituency_id&#39; do
        petition_1.update_columns(state: &#39;closed&#39;, closed_at: 3.days.ago)
        popular = Petition.all_popular_in_constituency(constituency_1, 4)
        expect(popular).to include(petition_1)
      end

      it &#39;excludes rejected petitions with signatures from the supplied constituency_id&#39; do
        petition_1.update_column(:state, Petition::REJECTED_STATE)
        popular = Petition.all_popular_in_constituency(constituency_1, 4)
        expect(popular).not_to include(petition_1)
      end

      it &#39;excludes hidden petitions with signatures from the supplied constituency_id&#39; do
        petition_1.update_column(:state, Petition::HIDDEN_STATE)
        popular = Petition.all_popular_in_constituency(constituency_1, 4)
        expect(popular).not_to include(petition_1)
      end

      it &#39;includes open petitions with signatures from the supplied constituency_id ordered by the count of signatures&#39; do
        popular = Petition.all_popular_in_constituency(constituency_1, 2)
        expect(popular).to eq [petition_3, petition_1]
      end

      it &#39;adds the constituency_signature_count attribute to the retrieved petitions&#39; do
        most_popular = Petition.all_popular_in_constituency(constituency_1, 1).first
        expect(most_popular).to respond_to :constituency_signature_count
        expect(most_popular.constituency_signature_count).to eq 30
      end

      it &#39;returns a scope&#39; do
        expect(Petition.all_popular_in_constituency(constituency_1, 1)).to be_an ActiveRecord::Relation
      end
    end

    describe &quot;.in_moderation&quot; do
      let!(:open_petition) { FactoryBot.create(:open_petition) }
      let!(:recent_petition) { FactoryBot.create(:sponsored_petition, :recent) }
      let!(:overdue_petition) { FactoryBot.create(:sponsored_petition, :overdue) }
      let!(:nearly_overdue_petition) { FactoryBot.create(:sponsored_petition, :nearly_overdue) }

      context &quot;with no arguments&quot; do
        it &quot;returns all petitions awaiting moderation&quot; do
          expect(Petition.in_moderation).to include(recent_petition, overdue_petition, nearly_overdue_petition)
        end

        it &quot;doesn&#39;t return petitions in other states&quot; do
          expect(Petition.in_moderation).not_to include(open_petition)
        end
      end

      context &quot;with a :from argument&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L632" class="js-smell-location">0</a>                  <a href="petition_spec.html#L646" class="js-smell-location">1</a>                  </div>  </li></ol>
        it &quot;returns all petitions awaiting moderation after the timestamp&quot; do
          expect(Petition.in_moderation(from: 5.days.ago)).to include(recent_petition)
        end

        it &quot;doesn&#39;t return petitions awaiting moderation before the timestamp&quot; do
          expect(Petition.in_moderation(from: 5.days.ago)).not_to include(overdue_petition, nearly_overdue_petition)
        end

        it &quot;doesn&#39;t return petitions in other states&quot; do
          expect(Petition.in_moderation(from: 5.days.ago)).not_to include(open_petition)
        end
      end

      context &quot;with a :to argument&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L632" class="js-smell-location">0</a>                  <a href="petition_spec.html#L646" class="js-smell-location">1</a>                  </div>  </li></ol>
        it &quot;returns all petitions awaiting moderation before the timestamp&quot; do
          expect(Petition.in_moderation(to: 7.days.ago)).to include(overdue_petition)
        end

        it &quot;doesn&#39;t return petitions awaiting moderation after the timestamp&quot; do
          expect(Petition.in_moderation(to: 7.days.ago)).not_to include(recent_petition, nearly_overdue_petition)
        end

        it &quot;doesn&#39;t return petitions in other states&quot; do
          expect(Petition.in_moderation(to: 7.days.ago)).not_to include(open_petition)
        end
      end

      context &quot;with both a :from and :to argument&quot; do
        it &quot;returns all petitions awaiting moderation between the timestamps&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 4 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L661" class="js-smell-location">0</a>                  <a href="petition_spec.html#L665" class="js-smell-location">1</a>                  <a href="petition_spec.html#L669" class="js-smell-location">2</a>                  <a href="petition_spec.html#L673" class="js-smell-location">3</a>                  </div>  </li></ol>
          expect(Petition.in_moderation(from: 7.days.ago, to: 5.days.ago)).to include(nearly_overdue_petition)
        end

        it &quot;doesn&#39;t return petitions awaiting moderation before the timestamp&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 4 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L661" class="js-smell-location">0</a>                  <a href="petition_spec.html#L665" class="js-smell-location">1</a>                  <a href="petition_spec.html#L669" class="js-smell-location">2</a>                  <a href="petition_spec.html#L673" class="js-smell-location">3</a>                  </div>  </li></ol>
          expect(Petition.in_moderation(from: 7.days.ago, to: 5.days.ago)).not_to include(overdue_petition)
        end

        it &quot;doesn&#39;t return petitions awaiting moderation after the timestamp&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 4 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L661" class="js-smell-location">0</a>                  <a href="petition_spec.html#L665" class="js-smell-location">1</a>                  <a href="petition_spec.html#L669" class="js-smell-location">2</a>                  <a href="petition_spec.html#L673" class="js-smell-location">3</a>                  </div>  </li></ol>
          expect(Petition.in_moderation(from: 7.days.ago, to: 5.days.ago)).not_to include(recent_petition)
        end

        it &quot;doesn&#39;t return petitions in other states&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 4 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L661" class="js-smell-location">0</a>                  <a href="petition_spec.html#L665" class="js-smell-location">1</a>                  <a href="petition_spec.html#L669" class="js-smell-location">2</a>                  <a href="petition_spec.html#L673" class="js-smell-location">3</a>                  </div>  </li></ol>
          expect(Petition.in_moderation(from: 7.days.ago, to: 5.days.ago)).not_to include(open_petition)
        end
      end
    end

    describe &quot;.recently_in_moderation&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L679" class="js-smell-location">0</a>                  <a href="petition_spec.html#L693" class="js-smell-location">1</a>                  <a href="petition_spec.html#L707" class="js-smell-location">2</a>                  </div>  </li></ol>
      let!(:recent_petition) { FactoryBot.create(:sponsored_petition, :recent) }
      let!(:overdue_petition) { FactoryBot.create(:sponsored_petition, :overdue) }
      let!(:nearly_overdue_petition) { FactoryBot.create(:sponsored_petition, :nearly_overdue) }

      it &quot;returns petitions that have recently joined the moderation queue&quot; do
        expect(Petition.recently_in_moderation).to include(recent_petition)
      end

      it &quot;doesn&#39;t return petitions that are overdue or nearly overdue&quot; do
        expect(Petition.recently_in_moderation).not_to include(overdue_petition, nearly_overdue_petition)
      end
    end

    describe &quot;.nearly_overdue_in_moderation&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L679" class="js-smell-location">0</a>                  <a href="petition_spec.html#L693" class="js-smell-location">1</a>                  <a href="petition_spec.html#L707" class="js-smell-location">2</a>                  </div>  </li></ol>
      let!(:recent_petition) { FactoryBot.create(:sponsored_petition, :recent) }
      let!(:overdue_petition) { FactoryBot.create(:sponsored_petition, :overdue) }
      let!(:nearly_overdue_petition) { FactoryBot.create(:sponsored_petition, :nearly_overdue) }

      it &quot;returns petitions that are nearly overdue for moderation&quot; do
        expect(Petition.nearly_overdue_in_moderation).to include(nearly_overdue_petition)
      end

      it &quot;doesn&#39;t return petitions that are overdue or have recently joined the moderation queue&quot; do
        expect(Petition.nearly_overdue_in_moderation).not_to include(recent_petition, overdue_petition)
      end
    end

    describe &quot;.overdue_in_moderation&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L679" class="js-smell-location">0</a>                  <a href="petition_spec.html#L693" class="js-smell-location">1</a>                  <a href="petition_spec.html#L707" class="js-smell-location">2</a>                  </div>  </li></ol>
      let!(:recent_petition) { FactoryBot.create(:sponsored_petition, :recent) }
      let!(:overdue_petition) { FactoryBot.create(:sponsored_petition, :overdue) }
      let!(:nearly_overdue_petition) { FactoryBot.create(:sponsored_petition, :nearly_overdue) }

      it &quot;returns petitions that are overdue for moderation&quot; do
        expect(Petition.overdue_in_moderation).to include(overdue_petition)
      end

      it &quot;doesn&#39;t return petitions that are nearly overdue or have recently joined the moderation queue&quot; do
        expect(Petition.overdue_in_moderation).not_to include(recent_petition, nearly_overdue_petition)
      end
    end

    describe &quot;.tagged_in_moderation&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L721" class="js-smell-location">0</a>                  <a href="petition_spec.html#L738" class="js-smell-location">1</a>                  </div>  </li></ol>
      let!(:recent_petition) { FactoryBot.create(:sponsored_petition, :recent) }
      let!(:overdue_petition) { FactoryBot.create(:sponsored_petition, :overdue) }
      let!(:nearly_overdue_petition) { FactoryBot.create(:sponsored_petition, :nearly_overdue) }
      let!(:tagged_recent_petition) { FactoryBot.create(:sponsored_petition, :recent, :tagged) }
      let!(:tagged_overdue_petition) { FactoryBot.create(:sponsored_petition, :overdue, :tagged) }
      let!(:tagged_nearly_overdue_petition) { FactoryBot.create(:sponsored_petition, :nearly_overdue, :tagged) }

      it &quot;returns petitions that are in the moderation queue and are tagged&quot; do
        expect(Petition.tagged_in_moderation).to include(tagged_recent_petition, tagged_overdue_petition, tagged_nearly_overdue_petition)
      end

      it &quot;doesn&#39;t return petitions that are in the moderation queue but are not tagged&quot; do
        expect(Petition.tagged_in_moderation).not_to include(recent_petition, overdue_petition, nearly_overdue_petition)
      end
    end

    describe &quot;.untagged_in_moderation&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L721" class="js-smell-location">0</a>                  <a href="petition_spec.html#L738" class="js-smell-location">1</a>                  </div>  </li></ol>
      let!(:recent_petition) { FactoryBot.create(:sponsored_petition, :recent) }
      let!(:overdue_petition) { FactoryBot.create(:sponsored_petition, :overdue) }
      let!(:nearly_overdue_petition) { FactoryBot.create(:sponsored_petition, :nearly_overdue) }
      let!(:tagged_recent_petition) { FactoryBot.create(:sponsored_petition, :recent, :tagged) }
      let!(:tagged_overdue_petition) { FactoryBot.create(:sponsored_petition, :overdue, :tagged) }
      let!(:tagged_nearly_overdue_petition) { FactoryBot.create(:sponsored_petition, :nearly_overdue, :tagged) }

      it &quot;returns petitions that are in the moderation queue and are untagged&quot; do
        expect(Petition.untagged_in_moderation).to include(recent_petition, overdue_petition, nearly_overdue_petition)
      end

      it &quot;doesn&#39;t return petitions that are in the moderation queue and are tagged&quot; do
        expect(Petition.untagged_in_moderation).not_to include(tagged_recent_petition, tagged_overdue_petition, tagged_nearly_overdue_petition)
      end
    end

    describe &quot;.signed_since&quot; do
      let!(:petition_1) { FactoryBot.create(:open_petition, last_signed_at: 2.hours.ago) }
      let!(:petition_2) { FactoryBot.create(:open_petition, last_signed_at: 30.minutes.ago) }
      let!(:petition_3) { FactoryBot.create(:open_petition, last_signed_at: 15.minutes.ago) }

      it &quot;returns petitions that have been signed since the timestamp&quot; do
        expect(Petition.signed_since(1.hour.ago)).to include(petition_2, petition_3)
      end

      it &quot;doesn&#39;t return petitions that haven&#39;t been signed since the timestamp&quot; do
        expect(Petition.signed_since(1.hour.ago)).not_to include(petition_1)
      end
    end
  end

  it_behaves_like &quot;a taggable model&quot;

  describe &quot;signature count&quot; do
    let(:petition) { FactoryBot.create(:pending_petition) }
    let(:signature) { FactoryBot.create(:pending_signature, petition: petition) }

    around do |example|
      perform_enqueued_jobs do
        example.run
      end
    end

    before do
      petition.validate_creator!
    end

    it &quot;returns 1 (the creator) for a new petition&quot; do
      expect(petition.signature_count).to eq(1)
    end

    it &quot;still returns 1 with a new signature&quot; do
      expect {
        signature
      }.not_to change {
        petition.reload.signature_count
      }.from(1)
    end

    it &quot;returns 2 when signature is validated&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 5 nodes</span>              <span>Locations:</span>                  <a href="invalidation_spec.html#L938" class="js-smell-location">0</a>                  <a href="invalidation_spec.html#L951" class="js-smell-location">1</a>                  <a href="invalidation_spec.html#L975" class="js-smell-location">2</a>                  <a href="petition_spec.html#L798" class="js-smell-location">3</a>                  <a href="petition_spec.html#L1538" class="js-smell-location">4</a>                  </div>  </li></ol>
      expect {
        signature.validate!
      }.to change {
        petition.reload.signature_count
      }.from(1).to(2)
    end
  end

  describe &#39;can_have_debate_added?&#39; do
    it &quot;is true if the petition is OPEN and the closed_at date is in the future&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L808" class="js-smell-location">0</a>                  <a href="petition_spec.html#L813" class="js-smell-location">1</a>                  </div>  </li></ol>
      petition = FactoryBot.build(:open_petition, :closed_at =&gt; 1.year.from_now)
      expect(petition.can_have_debate_added?).to be_truthy
    end

    it &quot;is true if the petition is OPEN and the closed_at date is in the past&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L808" class="js-smell-location">0</a>                  <a href="petition_spec.html#L813" class="js-smell-location">1</a>                  </div>  </li></ol>
      petition = FactoryBot.build(:open_petition, :closed_at =&gt; 2.minutes.ago)
      expect(petition.can_have_debate_added?).to be_truthy
    end

    it &quot;is false otherwise&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(can_have_debate_added?)::it#is false otherwise has a flog score of 46</span>          </div>  </li></ol>
      expect(FactoryBot.build(:open_petition, state: Petition::PENDING_STATE).can_have_debate_added?).to be_falsey
      expect(FactoryBot.build(:open_petition, state: Petition::HIDDEN_STATE).can_have_debate_added?).to be_falsey
      expect(FactoryBot.build(:open_petition, state: Petition::REJECTED_STATE).can_have_debate_added?).to be_falsey
      expect(FactoryBot.build(:open_petition, state: Petition::VALIDATED_STATE).can_have_debate_added?).to be_falsey
      expect(FactoryBot.build(:open_petition, state: Petition::SPONSORED_STATE).can_have_debate_added?).to be_falsey
    end
  end

  describe &quot;updating the scheduled debate date&quot; do
    context &quot;when the petition is open&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L828" class="js-smell-location">0</a>                  <a href="petition_spec.html#L898" class="js-smell-location">1</a>                  </div>  </li></ol>
      context &quot;and the debate date is changed to nil&quot; do
        subject(:petition) {
          FactoryBot.create(:open_petition,
            scheduled_debate_date: 2.days.from_now,
            debate_state: &quot;scheduled&quot;
          )
        }

        it &quot;sets the debate state to &#39;awaiting&#39;&quot; do
          expect {
            petition.update(scheduled_debate_date: nil)
          }.to change {
            petition.debate_state
          }.from(&quot;scheduled&quot;).to(&quot;awaiting&quot;)
        end
      end

      context &quot;and the debate date is in the future&quot; do
        subject(:petition) {
          FactoryBot.create(:open_petition,
            scheduled_debate_date: nil,
            debate_state: &quot;pending&quot;
          )
        }

        it &quot;sets the debate state to &#39;awaiting&#39;&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(updating the scheduled debate date)::context(when the petition is open)::context(and the debate date is in the future)::it#sets the debate state to 'awaiting' has a flog score of 25</span>          </div>  </li></ol>
          expect {
            petition.update(scheduled_debate_date: 2.days.from_now)
          }.to change {
            petition.debate_state
          }.from(&quot;pending&quot;).to(&quot;scheduled&quot;)
        end
      end

      context &quot;and the debate date is in the past&quot; do
        subject(:petition) {
          FactoryBot.create(:open_petition,
            scheduled_debate_date: nil,
            debate_state: &quot;pending&quot;
          )
        }

        it &quot;sets the debate state to &#39;debated&#39;&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(updating the scheduled debate date)::context(when the petition is open)::context(and the debate date is in the past)::it#sets the debate state to 'debated' has a flog score of 25</span>          </div>  </li></ol>
          expect {
            petition.update(scheduled_debate_date: 2.days.ago)
          }.to change {
            petition.debate_state
          }.from(&quot;pending&quot;).to(&quot;debated&quot;)
        end
      end

      context &quot;and the debate date is not changed&quot; do
        subject(:petition) {
          FactoryBot.create(:open_petition,
            scheduled_debate_date: Date.yesterday,
            debate_state: &quot;awaiting&quot;
          )
        }

        it &quot;does not change the debate state&quot; do
          expect {
            petition.update(open_at: 5.days.ago)
          }.not_to change {
            petition.debate_state
          }
        end
      end
    end

    context &quot;when the petition is closed&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L828" class="js-smell-location">0</a>                  <a href="petition_spec.html#L898" class="js-smell-location">1</a>                  </div>  </li></ol>
      context &quot;and the debate date is changed to nil&quot; do
        subject(:petition) {
          FactoryBot.create(:closed_petition,
            scheduled_debate_date: 2.days.from_now,
            debate_state: &quot;scheduled&quot;
          )
        }

        it &quot;sets the debate state to &#39;awaiting&#39;&quot; do
          expect {
            petition.update(scheduled_debate_date: nil)
          }.to change {
            petition.debate_state
          }.from(&quot;scheduled&quot;).to(&quot;awaiting&quot;)
        end
      end

      context &quot;and the debate date is in the future&quot; do
        subject(:petition) {
          FactoryBot.create(:closed_petition,
            scheduled_debate_date: nil,
            debate_state: &quot;awaiting&quot;
          )
        }

        it &quot;sets the debate state to &#39;awaiting&#39;&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(updating the scheduled debate date)::context(when the petition is closed)::context(and the debate date is in the future)::it#sets the debate state to 'awaiting' has a flog score of 25</span>          </div>  </li></ol>
          expect {
            petition.update(scheduled_debate_date: 2.days.from_now)
          }.to change {
            petition.debate_state
          }.from(&quot;awaiting&quot;).to(&quot;scheduled&quot;)
        end
      end

      context &quot;and the debate date is in the past&quot; do
        subject(:petition) {
          FactoryBot.create(:closed_petition,
            scheduled_debate_date: nil,
            debate_state: &quot;awaiting&quot;
          )
        }

        it &quot;sets the debate state to &#39;debated&#39;&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(updating the scheduled debate date)::context(when the petition is closed)::context(and the debate date is in the past)::it#sets the debate state to 'debated' has a flog score of 25</span>          </div>  </li></ol>
          expect {
            petition.update(scheduled_debate_date: 2.days.ago)
          }.to change {
            petition.debate_state
          }.from(&quot;awaiting&quot;).to(&quot;debated&quot;)
        end
      end

      context &quot;and the debate date is not changed&quot; do
        subject(:petition) {
          FactoryBot.create(:closed_petition,
            scheduled_debate_date: Date.yesterday,
            debate_state: &quot;awaiting&quot;
          )
        }

        it &quot;does not change the debate state&quot; do
          expect {
            petition.update(open_at: 5.days.ago)
          }.not_to change {
            petition.debate_state
          }
        end
      end
    end
  end

  describe &quot;#can_be_signed?&quot; do
    context &quot;when the petition is in the open state&quot; do
      let(:petition) { FactoryBot.build(:petition, state: Petition::OPEN_STATE) }

      it &quot;is true&quot; do
        expect(petition.can_be_signed?).to be_truthy
      end
    end

    (Petition::STATES - [Petition::OPEN_STATE]).each do |state|
      context &quot;when the petition is in the #{state} state&quot; do
        let(:petition) { FactoryBot.build(:petition, state: state) }

        it &quot;is false&quot; do
          expect(petition.can_be_signed?).to be_falsey
        end
      end
    end
  end

  describe &quot;#open?&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 5 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L989" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1009" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1074" class="js-smell-location">2</a>                  <a href="petition_spec.html#L1094" class="js-smell-location">3</a>                  <a href="petition_spec.html#L1154" class="js-smell-location">4</a>                  </div>  </li></ol>
    context &quot;when the state is open&quot; do
      let(:petition) { FactoryBot.build(:petition, state: Petition::OPEN_STATE) }

      it &quot;returns true&quot; do
        expect(petition.open?).to be_truthy
      end
    end

    context &quot;for other states&quot; do
      (Petition::STATES - [Petition::OPEN_STATE]).each do |state|
        let(:petition) { FactoryBot.build(:petition, state: state) }

        it &quot;is not open when state is #{state}&quot; do
          expect(petition.open?).to be_falsey
        end
      end
    end
  end

  describe &quot;#closed?&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 5 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L989" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1009" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1074" class="js-smell-location">2</a>                  <a href="petition_spec.html#L1094" class="js-smell-location">3</a>                  <a href="petition_spec.html#L1154" class="js-smell-location">4</a>                  </div>  </li></ol>
    context &quot;when the state is closed&quot; do
      let(:petition) { FactoryBot.build(:petition, state: Petition::CLOSED_STATE) }

      it &quot;returns true&quot; do
        expect(petition.closed?).to be_truthy
      end
    end

    context &quot;for other states&quot; do
      (Petition::STATES - [Petition::CLOSED_STATE]).each do |state|
        let(:petition) { FactoryBot.build(:petition, state: state) }

        it &quot;is not open when state is #{state}&quot; do
          expect(petition.open?).to be_falsey
        end
      end
    end
  end

  describe &quot;#closed_for_signing?&quot; do
    let(:now) { Time.current.change(sec: 0) }
    let(:yesterday) { now - 24.hours }

    context &quot;when the petition is open&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1033" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1041" class="js-smell-location">1</a>                  </div>  </li></ol>
      let(:petition) { FactoryBot.create(:open_petition) }

      it &quot;returns false&quot; do
        expect(petition.closed_for_signing?(now)).to be_falsey
      end
    end

    context &quot;when the petition is rejected&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1033" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1041" class="js-smell-location">1</a>                  </div>  </li></ol>
      let(:petition) { FactoryBot.create(:rejected_petition) }

      it &quot;returns true&quot; do
        expect(petition.closed_for_signing?(now)).to be_truthy
      end
    end

    context &quot;when the petition closed less than 24 hours ago&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1049" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1065" class="js-smell-location">1</a>                  </div>  </li></ol>
      let(:petition) { FactoryBot.create(:closed_petition, closed_at: yesterday + 1.second) }

      it &quot;returns false&quot; do
        expect(petition.closed_for_signing?(now)).to be_falsey
      end
    end

    context &quot;when the petition closed exactly 24 hours ago&quot; do
      let(:petition) { FactoryBot.create(:closed_petition, closed_at: yesterday) }

      it &quot;returns false&quot; do
        expect(petition.closed_for_signing?(now)).to be_falsey
      end
    end

    context &quot;when the petition closed more than 24 hours ago&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1049" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1065" class="js-smell-location">1</a>                  </div>  </li></ol>
      let(:petition) { FactoryBot.create(:closed_petition, closed_at: yesterday - 1.second) }

      it &quot;returns true&quot; do
        expect(petition.closed_for_signing?(now)).to be_truthy
      end
    end
  end

  describe &quot;#rejected?&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 5 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L989" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1009" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1074" class="js-smell-location">2</a>                  <a href="petition_spec.html#L1094" class="js-smell-location">3</a>                  <a href="petition_spec.html#L1154" class="js-smell-location">4</a>                  </div>  </li></ol>
    context &quot;when the state is rejected&quot; do
      let(:petition) { FactoryBot.build(:petition, state: Petition::REJECTED_STATE) }

      it &quot;returns true&quot; do
        expect(petition.rejected?).to be_truthy
      end
    end

    context &quot;for other states&quot; do
      (Petition::STATES - [Petition::REJECTED_STATE]).each do |state|
        let(:petition) { FactoryBot.build(:petition, state: state) }

        it &quot;is not rejected when state is #{state}&quot; do
          expect(petition.rejected?).to be_falsey
        end
      end
    end
  end

  describe &quot;#stopped?&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 5 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L989" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1009" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1074" class="js-smell-location">2</a>                  <a href="petition_spec.html#L1094" class="js-smell-location">3</a>                  <a href="petition_spec.html#L1154" class="js-smell-location">4</a>                  </div>  </li></ol>
    context &quot;when the state is stopped&quot; do
      let(:petition) { FactoryBot.build(:petition, state: Petition::STOPPED_STATE) }

      it &quot;returns true&quot; do
        expect(petition.stopped?).to be_truthy
      end
    end

    context &quot;for other states&quot; do
      (Petition::STATES - [Petition::STOPPED_STATE]).each do |state|
        let(:petition) { FactoryBot.build(:petition, state: state) }

        it &quot;is not stopped when state is #{state}&quot; do
          expect(petition.stopped?).to be_falsey
        end
      end
    end
  end

  describe &quot;#hidden?&quot; do
    context &quot;when the state is hidden&quot; do
      it &quot;returns true&quot; do
        expect(FactoryBot.build(:petition, :state =&gt; Petition::HIDDEN_STATE).hidden?).to be_truthy
      end
    end

    context &quot;for other states&quot; do
      (Petition::STATES - [Petition::HIDDEN_STATE]).each do |state|
        let(:petition) { FactoryBot.build(:petition, state: state) }

        it &quot;is not hidden when state is #{state}&quot; do
          expect(petition.hidden?).to be_falsey
        end
      end
    end
  end

  describe &quot;#visible?&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 4 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1132" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1174" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1196" class="js-smell-location">2</a>                  <a href="petition_spec.html#L1218" class="js-smell-location">3</a>                  </div>  </li></ol>
    context &quot;for moderated states&quot; do
      Petition::VISIBLE_STATES.each do |state|
        let(:petition) { FactoryBot.build(:petition, state: state) }

        it &quot;is visible when state is #{state}&quot; do
          expect(petition.visible?).to be_truthy
        end
      end
    end

    context &quot;for other states&quot; do
      (Petition::STATES - Petition::VISIBLE_STATES).each do |state|
        let(:petition) { FactoryBot.build(:petition, state: state) }

        it &quot;is not visible when state is #{state}&quot; do
          expect(petition.visible?).to be_falsey
        end
      end
    end
  end

  describe &quot;#flagged?&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 5 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L989" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1009" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1074" class="js-smell-location">2</a>                  <a href="petition_spec.html#L1094" class="js-smell-location">3</a>                  <a href="petition_spec.html#L1154" class="js-smell-location">4</a>                  </div>  </li></ol>
    context &quot;when the state is flagged&quot; do
      let(:petition) { FactoryBot.build(:petition, state: Petition::FLAGGED_STATE) }

      it &quot;returns true&quot; do
        expect(petition.flagged?).to be_truthy
      end
    end

    context &quot;for other states&quot; do
      (Petition::STATES - [Petition::FLAGGED_STATE]).each do |state|
        let(:petition) { FactoryBot.build(:petition, state: state) }

        it &quot;is not open when state is #{state}&quot; do
          expect(petition.flagged?).to be_falsey
        end
      end
    end
  end

  describe &quot;#in_moderation?&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 4 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1132" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1174" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1196" class="js-smell-location">2</a>                  <a href="petition_spec.html#L1218" class="js-smell-location">3</a>                  </div>  </li></ol>
    context &quot;for in moderation states&quot; do
      Petition::IN_MODERATION_STATES.each do |state|
        let(:petition) { FactoryBot.build(:petition, state: state) }

        it &quot;is in moderation when state is #{state}&quot; do
          expect(petition.in_moderation?).to be_truthy
        end
      end
    end

    context &quot;for other states&quot; do
      (Petition::STATES - Petition::IN_MODERATION_STATES).each do |state|
        let(:petition) { FactoryBot.build(:petition, state: state) }

        it &quot;is not in moderation when state is #{state}&quot; do
          expect(petition.in_moderation?).to be_falsey
        end
      end
    end
  end

  describe &quot;#moderated?&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 4 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1132" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1174" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1196" class="js-smell-location">2</a>                  <a href="petition_spec.html#L1218" class="js-smell-location">3</a>                  </div>  </li></ol>
    context &quot;for moderated states&quot; do
      Petition::MODERATED_STATES.each do |state|
        let(:petition) { FactoryBot.build(:petition, state: state) }

        it &quot;is moderated when state is #{state}&quot; do
          expect(petition.moderated?).to be_truthy
        end
      end
    end

    context &quot;for other states&quot; do
      (Petition::STATES - Petition::MODERATED_STATES).each do |state|
        let(:petition) { FactoryBot.build(:petition, state: state) }

        it &quot;is not moderated when state is #{state}&quot; do
          expect(petition.moderated?).to be_falsey
        end
      end
    end
  end

  describe &quot;#in_todo_list?&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 4 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1132" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1174" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1196" class="js-smell-location">2</a>                  <a href="petition_spec.html#L1218" class="js-smell-location">3</a>                  </div>  </li></ol>
    context &quot;for todo list states&quot; do
      Petition::TODO_LIST_STATES.each do |state|
        let(:petition) { FactoryBot.build(:petition, state: state) }

        it &quot;is in todo list when the state is #{state}&quot; do
          expect(petition.in_todo_list?).to be_truthy
        end
      end
    end

    context &quot;for other states&quot; do
      (Petition::STATES - Petition::TODO_LIST_STATES).each do |state|
        let(:petition) { FactoryBot.build(:petition, state: state) }

        it &quot;is not in todo list when the state is #{state}&quot; do
          expect(petition.in_todo_list?).to be_falsey
        end
      end
    end
  end

  describe &quot;counting validated signatures&quot; do
    let(:petition) { FactoryBot.build(:petition) }

    it &quot;only counts validated signtatures&quot; do
      expect(petition.signatures).to receive(:validated).and_return(double(:valid_signatures, :count =&gt; 123))
      expect(petition.count_validated_signatures).to eq(123)
    end
  end

  describe &quot;.close_petitions!&quot; do
    context &quot;when a petition is in the open state and the closing date has not passed&quot; do
      let(:open_at) { Site.opened_at_for_closing(1.day.from_now) }
      let!(:petition) { FactoryBot.create(:open_petition, open_at: open_at) }

      it &quot;does not close the petition&quot; do
        expect{
          described_class.close_petitions!
        }.not_to change{ petition.reload.state }
      end
    end

    context &quot;when a petition is in the open state and closed_at has passed&quot; do
      let(:open_at) { Site.opened_at_for_closing - 1.day }
      let!(:petition) { FactoryBot.create(:open_petition, open_at: open_at) }

      it &quot;does close the petition&quot; do
        expect{
          described_class.close_petitions!
        }.to change{ petition.reload.state }.from(&#39;open&#39;).to(&#39;closed&#39;)
      end
    end
  end

  describe &quot;.close_petitions_early!&quot; do
    let(:open_at) { Date.civil(2017, 4, 1).noon }
    let(:dissolution_at) { Time.utc(2017, 5, 2, 23, 1, 0).in_time_zone }
    let!(:petition) { FactoryBot.create(:open_petition, open_at: open_at) }

    it &quot;closes the petition&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1278" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1295" class="js-smell-location">1</a>                  </div>  </li></ol>
      expect{
        described_class.close_petitions_early!(dissolution_at)
      }.to change{ petition.reload.state }.from(&#39;open&#39;).to(&#39;closed&#39;)
    end

    it &quot;sets closed_at to the dissolution timestamp&quot; do
      expect{
        described_class.close_petitions_early!(dissolution_at)
      }.to change{ petition.reload.closed_at }.from(nil).to(dissolution_at)
    end
  end

  describe &quot;.stop_petitions_early!&quot; do
    let(:dissolution_at) { Time.utc(2017, 5, 2, 23, 1, 0).in_time_zone }
    let!(:petition) { FactoryBot.create(:pending_petition) }

    it &quot;stops the petition&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1278" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1295" class="js-smell-location">1</a>                  </div>  </li></ol>
      expect{
        described_class.stop_petitions_early!(dissolution_at)
      }.to change{ petition.reload.state }.from(&#39;pending&#39;).to(&#39;stopped&#39;)
    end

    it &quot;sets stopped_at to the dissolution timestamp&quot; do
      expect{
        described_class.stop_petitions_early!(dissolution_at)
      }.to change{ petition.reload.stopped_at }.from(nil).to(dissolution_at)
    end
  end

  describe &quot;.in_need_of_closing&quot; do
    context &quot;when a petition is in the closed state&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1309" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1410" class="js-smell-location">1</a>                  </div>  </li></ol>
      let!(:petition) { FactoryBot.create(:closed_petition) }

      it &quot;does not find the petition&quot; do
        expect(described_class.in_need_of_closing.to_a).not_to include(petition)
      end
    end

    context &quot;when a petition is in the open state and the closing date has not passed&quot; do
      let(:open_at) { Site.opened_at_for_closing(1.day.from_now) }
      let!(:petition) { FactoryBot.create(:open_petition, open_at: open_at) }

      it &quot;does not find the petition&quot; do
        expect(described_class.in_need_of_closing.to_a).not_to include(petition)
      end
    end

    context &quot;when a petition is in the open state and the closing date has passed&quot; do
      let(:open_at) { Site.opened_at_for_closing - 1.day }
      let!(:petition) { FactoryBot.create(:open_petition, open_at: open_at) }

      it &quot;finds the petition&quot; do
        expect(described_class.in_need_of_closing.to_a).to include(petition)
      end
    end
  end

  describe &quot;.in_need_of_stopping&quot; do
    let!(:open_petition) { FactoryBot.create(:open_petition, created_at: 2.weeks.ago) }
    let!(:pending_petition) { FactoryBot.create(:pending_petition, created_at: 6.weeks.ago) }
    let!(:validated_petition) { FactoryBot.create(:validated_petition, created_at: 2.weeks.ago) }
    let!(:sponsored_petition) { FactoryBot.create(:sponsored_petition, created_at: 6.weeks.ago) }
    let!(:flagged_petition) { FactoryBot.create(:flagged_petition, created_at: 2.weeks.ago) }
    let!(:stoppable_petitions) { [pending_petition, validated_petition, sponsored_petition, flagged_petition] }
    let!(:recent_petitions) { [validated_petition, flagged_petition] }

    context &quot;when not passing a date&quot; do
      it &quot;does not find open petitions&quot; do
        expect(described_class.in_need_of_stopping).not_to include(open_petition)
      end

      it &quot;includes all stoppable petitions&quot; do
        expect(described_class.in_need_of_stopping).to include(*stoppable_petitions)
      end
    end

    context &quot;when passing a date&quot; do
      let(:cutoff_date) { 1.month.ago }

      it &quot;does not find open petitions&quot; do
        expect(described_class.in_need_of_stopping(cutoff_date)).not_to include(open_petition)
      end

      it &quot;includes only the stoppable petitions created after that date&quot; do
        expect(described_class.in_need_of_stopping(cutoff_date)).to include(*recent_petitions)
      end
    end
  end

  describe &quot;.open_at_dissolution&quot; do
    let(:closed_at_dissolution) { Site.opened_at_for_closing(Date.civil(2017, 5, 2).end_of_day) }
    let(:open_at_dissolution) { Site.opened_at_for_closing(Date.civil(2017, 5, 3).end_of_day) }

    let!(:closed_petition) { FactoryBot.create(:open_petition, open_at: closed_at_dissolution) }
    let!(:open_petition) { FactoryBot.create(:open_petition, open_at: open_at_dissolution) }

    context &quot;when parliament is not dissolving&quot; do
      before do
        allow(Parliament).to receive(:dissolution_at).and_return(nil)
      end

      it &quot;returns an empty relation&quot; do
        expect(described_class.open_at_dissolution).to be_empty
      end
    end

    context &quot;when parliament is dissolving&quot; do
      let(:dissolution_at) { Time.utc(2017, 5, 2, 23, 1, 0).in_time_zone }
      let(:now) { Date.civil(2017, 4, 22).noon }

      before do
        allow(Parliament).to receive(:dissolution_at).and_return(dissolution_at)
      end

      around do |example|
        travel_to(now) { example.run }
      end

      it &quot;includes petitions open after the dissolution&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1397" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1402" class="js-smell-location">1</a>                  </div>  </li>  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(.open_at_dissolution)::context(when parliament is dissolving)::it#includes petitions open after the dissolution has a flog score of 30</span>          </div>  </li></ol>
        expect(open_petition.deadline).to eq(Date.civil(2017, 5, 3).end_of_day)
        expect(described_class.open_at_dissolution).to include(open_petition)
      end

      it &quot;excludes petitions closed before the dissolution&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1397" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1402" class="js-smell-location">1</a>                  </div>  </li>  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(.open_at_dissolution)::context(when parliament is dissolving)::it#excludes petitions closed before the dissolution has a flog score of 30</span>          </div>  </li></ol>
        expect(closed_petition.deadline).to eq(Date.civil(2017, 5, 2).end_of_day)
        expect(described_class.open_at_dissolution).not_to include(closed_petition)
      end
    end
  end

  describe &quot;.in_need_of_marking_as_debated&quot; do
    context &quot;when a petition is not in the the &#39;awaiting&#39; debate state&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1309" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1410" class="js-smell-location">1</a>                  </div>  </li></ol>
      let!(:petition) { FactoryBot.create(:open_petition) }

      it &quot;does not find the petition&quot; do
        expect(described_class.in_need_of_marking_as_debated.to_a).not_to include(petition)
      end
    end

    context &quot;when a petition is awaiting a debate date&quot; do
      let!(:petition) {
        FactoryBot.create(:open_petition,
          debate_state: &#39;awaiting&#39;,
          scheduled_debate_date: nil
        )
      }

      it &quot;does not find the petition&quot; do
        expect(described_class.in_need_of_marking_as_debated.to_a).not_to include(petition)
      end
    end

    context &quot;when a petition is awaiting a debate&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1431" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1463" class="js-smell-location">1</a>                  </div>  </li></ol>
      let!(:petition) {
        FactoryBot.create(:open_petition,
          debate_state: &#39;awaiting&#39;,
          scheduled_debate_date: 2.days.from_now
        )
      }

      it &quot;does not find the petition&quot; do
        expect(described_class.in_need_of_marking_as_debated.to_a).not_to include(petition)
      end
    end

    context &quot;when a petition debate date has passed but is still marked as &#39;awaiting&#39;&quot; do
      let(:petition) {
        FactoryBot.build(:open_petition,
          debate_state: &#39;awaiting&#39;,
          scheduled_debate_date: Date.tomorrow
        )
      }

      before do
        travel_to(2.days.ago) do
          petition.save
        end
      end

      it &quot;finds the petition&quot; do
        expect(described_class.in_need_of_marking_as_debated.to_a).to include(petition)
      end
    end

    context &quot;when a petition debate date has passed and it marked as &#39;debated&#39;&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1431" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1463" class="js-smell-location">1</a>                  </div>  </li></ol>
      let!(:petition) {
        FactoryBot.create(:open_petition,
          debate_state: &#39;debated&#39;,
          scheduled_debate_date: 2.days.ago
        )
      }

      it &quot;does not find the petition&quot; do
        expect(described_class.in_need_of_marking_as_debated.to_a).not_to include(petition)
      end
    end
  end

  describe &quot;.mark_petitions_as_debated!&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="archived/petition_spec.html#L257" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1477" class="js-smell-location">1</a>                  </div>  </li></ol>
    context &quot;when a petition is in the scheduled debate state and the debate date has passed&quot; do
      let(:petition) {
        FactoryBot.build(:open_petition,
          debate_state: &#39;scheduled&#39;,
          scheduled_debate_date: Date.tomorrow
        )
      }

      before do
        travel_to(2.days.ago) do
          petition.save
        end
      end

      it &quot;marks the petition as debated&quot; do
        expect{
          described_class.mark_petitions_as_debated!
        }.to change{ petition.reload.debate_state }.from(&#39;scheduled&#39;).to(&#39;debated&#39;)
      end
    end

    context &quot;when a petition is in the scheduled debate state and the debate date has not passed&quot; do
      let(:petition) {
        FactoryBot.build(:open_petition,
          debate_state: &#39;scheduled&#39;,
          scheduled_debate_date: Date.tomorrow
        )
      }

      before do
        petition.save
      end

      it &quot;does not mark the petition as debated&quot; do
        expect{
          described_class.mark_petitions_as_debated!
        }.not_to change{ petition.reload.debate_state }
      end
    end
  end

  describe &quot;.unarchived&quot; do
    let!(:archived_petition) { FactoryBot.create(:closed_petition, archived_at: 1.hour.ago) }
    let!(:unarchived_petition) { FactoryBot.create(:closed_petition, archived_at: nil) }

    it &quot;includes unarchived petitions&quot; do
      expect(described_class.unarchived).to include(unarchived_petition)
    end

    it &quot;excludes archived petitions&quot; do
      expect(described_class.unarchived).not_to include(archived_petition)
    end
  end

  describe &quot;#update_signature_count!&quot; do
    let!(:petition) { FactoryBot.create(:open_petition, attributes) }

    context &quot;when there are petitions with invalid signature counts&quot; do
      let(:attributes) { { created_at: 2.days.ago, updated_at: 2.days.ago, signature_count: 100 } }

      it &quot;updates the signature count&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 5 nodes</span>              <span>Locations:</span>                  <a href="invalidation_spec.html#L938" class="js-smell-location">0</a>                  <a href="invalidation_spec.html#L951" class="js-smell-location">1</a>                  <a href="invalidation_spec.html#L975" class="js-smell-location">2</a>                  <a href="petition_spec.html#L798" class="js-smell-location">3</a>                  <a href="petition_spec.html#L1538" class="js-smell-location">4</a>                  </div>  </li></ol>
        expect{
          petition.update_signature_count!
        }.to change{ petition.reload.signature_count }.from(100).to(1)
      end

      it &quot;updates the updated_at timestamp&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="../jobs/petition_count_job_spec.html#L41" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1544" class="js-smell-location">1</a>                  </div>  </li>  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#update_signature_count!)::context(when there are petitions with invalid signature counts)::it#updates the updated_at timestamp has a flog score of 28</span>          </div>  </li></ol>
        expect{
          petition.update_signature_count!
        }.to change{ petition.reload.updated_at }.to(be_within(1.second).of(Time.current))
      end
    end
  end

  describe &quot;#increment_signature_count!&quot; do
    let(:signature_count) { 8 }
    let(:petition) do
      FactoryBot.create(:open_petition, {
        signature_count: signature_count,
        last_signed_at: 2.days.ago,
        updated_at: 2.days.ago,
        creator_attributes: { validated_at: 5.days.ago }
      })
    end

    context &quot;when there is one more signature&quot; do
      before do
        FactoryBot.create(:validated_signature, petition: petition)
      end

      it &quot;increases the signature count by 1&quot; do
        expect{
          petition.increment_signature_count!
        }.to change{ petition.signature_count }.by(1)
      end

      it &quot;updates the last_signed_at timestamp&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 9 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1574" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1579" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1598" class="js-smell-location">2</a>                  <a href="petition_spec.html#L1603" class="js-smell-location">3</a>                  <a href="petition_spec.html#L1782" class="js-smell-location">4</a>                  <a href="signature_spec.html#L1379" class="js-smell-location">5</a>                  <a href="signature_spec.html#L1384" class="js-smell-location">6</a>                  <a href="signature_spec.html#L1662" class="js-smell-location">7</a>                  <a href="signature_spec.html#L1675" class="js-smell-location">8</a>                  </div>  </li></ol>
        petition.increment_signature_count!
        expect(petition.last_signed_at).to be_within(1.second).of(Time.current)
      end

      it &quot;updates the updated_at timestamp&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 9 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1574" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1579" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1598" class="js-smell-location">2</a>                  <a href="petition_spec.html#L1603" class="js-smell-location">3</a>                  <a href="petition_spec.html#L1782" class="js-smell-location">4</a>                  <a href="signature_spec.html#L1379" class="js-smell-location">5</a>                  <a href="signature_spec.html#L1384" class="js-smell-location">6</a>                  <a href="signature_spec.html#L1662" class="js-smell-location">7</a>                  <a href="signature_spec.html#L1675" class="js-smell-location">8</a>                  </div>  </li></ol>
        petition.increment_signature_count!
        expect(petition.updated_at).to be_within(1.second).of(Time.current)
      end
    end

    context &quot;when there is more than one signature&quot; do
      before do
        5.times do
          FactoryBot.create(:validated_signature, petition: petition)
        end
      end

      it &quot;increases the signature count by 5&quot; do
        expect{
          petition.increment_signature_count!
        }.to change{ petition.signature_count }.by(5)
      end

      it &quot;updates the last_signed_at timestamp&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 9 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1574" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1579" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1598" class="js-smell-location">2</a>                  <a href="petition_spec.html#L1603" class="js-smell-location">3</a>                  <a href="petition_spec.html#L1782" class="js-smell-location">4</a>                  <a href="signature_spec.html#L1379" class="js-smell-location">5</a>                  <a href="signature_spec.html#L1384" class="js-smell-location">6</a>                  <a href="signature_spec.html#L1662" class="js-smell-location">7</a>                  <a href="signature_spec.html#L1675" class="js-smell-location">8</a>                  </div>  </li></ol>
        petition.increment_signature_count!
        expect(petition.last_signed_at).to be_within(1.second).of(Time.current)
      end

      it &quot;updates the updated_at timestamp&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 9 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1574" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1579" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1598" class="js-smell-location">2</a>                  <a href="petition_spec.html#L1603" class="js-smell-location">3</a>                  <a href="petition_spec.html#L1782" class="js-smell-location">4</a>                  <a href="signature_spec.html#L1379" class="js-smell-location">5</a>                  <a href="signature_spec.html#L1384" class="js-smell-location">6</a>                  <a href="signature_spec.html#L1662" class="js-smell-location">7</a>                  <a href="signature_spec.html#L1675" class="js-smell-location">8</a>                  </div>  </li></ol>
        petition.increment_signature_count!
        expect(petition.updated_at).to be_within(1.second).of(Time.current)
      end
    end

    context &quot;when the petition is first sponsored&quot; do
      let(:petition) do
        FactoryBot.create(:petition, {
          state: &quot;pending&quot;,
          signature_count: 0,
          last_signed_at: nil,
          updated_at: 2.days.ago
        })
      end

      it &quot;records changes the state from &#39;pending&#39; to &#39;validated&#39;&quot; do
        expect {
          petition.increment_signature_count!
        }.to change{
          petition.state
        }.from(Petition::PENDING_STATE).to(Petition::VALIDATED_STATE)
      end
    end

    context &quot;when the signature count crosses the threshold for moderation&quot; do
      let(:signature_count) { 4 }

      before do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1631" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1723" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1740" class="js-smell-location">2</a>                  </div>  </li></ol>
        expect(Site).to receive(:threshold_for_response).and_return(5)
        FactoryBot.create(:validated_signature, petition: petition)
      end

      context &quot;having already been validated by a sponsor&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1636" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1662" class="js-smell-location">1</a>                  </div>  </li></ol>
        let(:petition) do
          FactoryBot.create(:validated_petition, {
            signature_count: signature_count,
            last_signed_at: 2.days.ago,
            updated_at: 2.days.ago
          })
        end

        it &quot;records the time it happened&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#increment_signature_count!)::context(when the signature count crosses the threshold for moderation)::context(having already been validated by a sponsor)::it#records the time it happened has a flog score of 27</span>          </div>  </li></ol>
          expect {
            petition.increment_signature_count!
          }.to change {
            petition.moderation_threshold_reached_at
          }.to be_within(1.second).of(Time.current)
        end

        it &quot;records changes the state from &#39;validated&#39; to &#39;sponsored&#39;&quot; do
          expect {
            petition.increment_signature_count!
          }.to change {
            petition.state
          }.from(Petition::VALIDATED_STATE).to(Petition::SPONSORED_STATE)
        end
      end

      context &quot;without having been validated by a sponsor yet&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1636" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1662" class="js-smell-location">1</a>                  </div>  </li></ol>
        let(:petition) do
          FactoryBot.create(:pending_petition, {
            signature_count: signature_count,
            last_signed_at: 2.days.ago,
            updated_at: 2.days.ago
          })
        end

        it &quot;records the time it happened&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#increment_signature_count!)::context(when the signature count crosses the threshold for moderation)::context(without having been validated by a sponsor yet)::it#records the time it happened has a flog score of 27</span>          </div>  </li></ol>
          expect {
            petition.increment_signature_count!
          }.to change {
            petition.moderation_threshold_reached_at
          }.to be_within(1.second).of(Time.current)
        end

        it &quot;records changes the state from &#39;validated&#39; to &#39;sponsored&#39;&quot; do
          expect {
            petition.increment_signature_count!
          }.to change {
            petition.state
          }.from(Petition::PENDING_STATE).to(Petition::SPONSORED_STATE)
        end
      end
    end

    context &quot;when the signature count is higher than the threshold for moderation&quot; do
      let(:signature_count) { 100 }

      before do
        FactoryBot.create(:validated_signature, petition: petition)
      end

      context &quot;and moderation_threshold_reached_at is nil&quot; do
        let(:petition) do
          FactoryBot.create(:open_petition, {
            signature_count: signature_count,
            last_signed_at: 2.days.ago,
            updated_at: 2.days.ago,
            moderation_threshold_reached_at: nil
          })
        end

        it &quot;doesn&#39;t change the state to sponsored&quot; do
          expect {
            petition.increment_signature_count!
          }.not_to change { petition.state }
        end

        it &quot;doesn&#39;t update the moderation_threshold_reached_at column&quot; do
          expect {
            petition.increment_signature_count!
          }.not_to change { petition.moderation_threshold_reached_at }
        end
      end
    end

    context &quot;when the signature count crosses the threshold for a response&quot; do
      let(:signature_count) { 9 }

      before do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1631" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1723" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1740" class="js-smell-location">2</a>                  </div>  </li></ol>
        expect(Site).to receive(:threshold_for_response).and_return(10)
        FactoryBot.create(:validated_signature, petition: petition)
      end

      it &quot;records the time it happened&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#increment_signature_count!)::context(when the signature count crosses the threshold for a response)::it#records the time it happened has a flog score of 26</span>          </div>  </li></ol>
        expect {
          petition.increment_signature_count!
        }.to change {
          petition.response_threshold_reached_at
        }.to be_within(1.second).of(Time.current)
      end
    end

    context &quot;when the signature count crosses the threshold for a debate&quot; do
      let(:signature_count) { 99 }

      before do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1631" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1723" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1740" class="js-smell-location">2</a>                  </div>  </li></ol>
        expect(Site).to receive(:threshold_for_debate).and_return(100)
        FactoryBot.create(:validated_signature, petition: petition)
      end

      it &quot;records the time it happened&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#increment_signature_count!)::context(when the signature count crosses the threshold for a debate)::it#records the time it happened has a flog score of 26</span>          </div>  </li></ol>
        expect {
          petition.increment_signature_count!
        }.to change {
          petition.debate_threshold_reached_at
        }.to be_within(1.second).of(Time.current)
      end

      it &quot;sets the debate_state to &#39;awaiting&#39;&quot; do
        expect {
          petition.increment_signature_count!
        }.to change {
          petition.debate_state
        }.from(&quot;pending&quot;).to(&quot;awaiting&quot;)
      end
    end
  end

  describe &quot;#decrement_signature_count!&quot; do
    let(:signature_count) { 8 }
    let(:petition) do
      FactoryBot.create(:open_petition, {
        signature_count: signature_count,
        last_signed_at: 2.days.ago,
        updated_at: 2.days.ago,
        response_threshold_reached_at: 2.days.ago,
        debate_threshold_reached_at: 2.days.ago,
        debate_state: &#39;awaiting&#39;
      })
    end

    it &quot;decreases the signature count by 1&quot; do
      expect{
        petition.decrement_signature_count!
      }.to change{ petition.signature_count }.by(-1)
    end

    it &quot;updates the updated_at timestamp&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 9 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1574" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1579" class="js-smell-location">1</a>                  <a href="petition_spec.html#L1598" class="js-smell-location">2</a>                  <a href="petition_spec.html#L1603" class="js-smell-location">3</a>                  <a href="petition_spec.html#L1782" class="js-smell-location">4</a>                  <a href="signature_spec.html#L1379" class="js-smell-location">5</a>                  <a href="signature_spec.html#L1384" class="js-smell-location">6</a>                  <a href="signature_spec.html#L1662" class="js-smell-location">7</a>                  <a href="signature_spec.html#L1675" class="js-smell-location">8</a>                  </div>  </li></ol>
      petition.decrement_signature_count!
      expect(petition.updated_at).to be_within(1.second).of(Time.current)
    end

    context &quot;when the signature count is 1&quot; do
      let(:signature_count) { 1 }

      it &quot;does nothing&quot; do
        expect{
          petition.decrement_signature_count!
        }.not_to change{ petition.signature_count }
      end
    end

    context &quot;when the signature count crosses below the threshold for a response&quot; do
      let(:signature_count) { 10 }

      before do
        expect(Site).to receive(:threshold_for_response).and_return(10)
      end

      it &quot;resets the timestamp&quot; do
        petition.decrement_signature_count!
        expect(petition.response_threshold_reached_at).to be_nil
      end
    end

    context &quot;when the signature count crosses below the threshold for a debate&quot; do
      let(:signature_count) { 100 }

      before do
        expect(Site).to receive(:threshold_for_debate).and_return(100)
      end

      it &quot;records the time it happened&quot; do
        petition.decrement_signature_count!
        expect(petition.debate_threshold_reached_at).to be_nil
      end

      it &quot;sets the debate_state to &#39;pending&#39;&quot; do
        petition.decrement_signature_count!
        expect(petition.debate_state).to eq(&quot;pending&quot;)
      end
    end
  end

  describe &quot;will_reach_threshold_for_moderation?&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1829" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1875" class="js-smell-location">1</a>                  </div>  </li></ol>
    context &quot;when moderation_threshold_reached_at is not present&quot; do
      let(:petition) { FactoryBot.create(:validated_petition, signature_count: signature_count) }

      before do
        expect(Site).to receive(:threshold_for_moderation).and_return(5)
      end

      context &quot;and the signature count is less than the threshold&quot; do
        let(:signature_count) { 4 }

        it &quot;is falsey&quot; do
          expect(petition.will_reach_threshold_for_moderation?).to be_falsey
        end
      end

      context &quot;and the signature count is one less than the threshold&quot; do
        let(:signature_count) { 5 }

        it &quot;is truthy&quot; do
          expect(petition.will_reach_threshold_for_moderation?).to be_truthy
        end
      end

      context &quot;and the signature count is more than the threshold&quot; do
        let(:signature_count) { 6 }

        it &quot;is truthy&quot; do
          expect(petition.will_reach_threshold_for_moderation?).to be_truthy
        end
      end
    end

    context &quot;when moderation_threshold_reached_at is present&quot; do
      let(:petition) { FactoryBot.create(:sponsored_petition) }

      before do
        expect(Site).not_to receive(:threshold_for_response)
      end

      it &quot;is falsey&quot; do
        expect(petition.will_reach_threshold_for_moderation?).to be_falsey
      end
    end
  end

  describe &quot;at_threshold_for_moderation?&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1829" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1875" class="js-smell-location">1</a>                  </div>  </li></ol>
    context &quot;when moderation_threshold_reached_at is not present&quot; do
      let(:petition) { FactoryBot.create(:validated_petition, signature_count: signature_count) }

      before do
        expect(Site).to receive(:threshold_for_moderation).and_return(5)
      end

      context &quot;and the signature count is less than the threshold&quot; do
        let(:signature_count) { 5 }

        it &quot;is falsey&quot; do
          expect(petition.at_threshold_for_moderation?).to be_falsey
        end
      end

      context &quot;and the signature count is equal than the threshold&quot; do
        let(:signature_count) { 6 }

        it &quot;is truthy&quot; do
          expect(petition.at_threshold_for_moderation?).to be_truthy
        end
      end

      context &quot;and the signature count is more than the threshold&quot; do
        let(:signature_count) { 7 }

        it &quot;is truthy&quot; do
          expect(petition.at_threshold_for_moderation?).to be_truthy
        end
      end
    end

    context &quot;when moderation_threshold_reached_at is present&quot; do
      let(:petition) { FactoryBot.create(:sponsored_petition) }

      before do
        expect(Site).not_to receive(:threshold_for_response)
      end

      it &quot;is falsey&quot; do
        expect(petition.at_threshold_for_moderation?).to be_falsey
      end
    end
  end

  describe &quot;at_threshold_for_response?&quot; do
    context &quot;when response_threshold_reached_at is not present&quot; do
      let(:petition) { FactoryBot.create(:open_petition, signature_count: signature_count) }

      before do
        expect(Site).to receive(:threshold_for_response).and_return(10)
      end

      context &quot;and the signature count is 2 or more less than the threshold&quot; do
        let(:signature_count) { 8 }

        it &quot;is falsey&quot; do
          expect(petition.at_threshold_for_response?).to be_falsey
        end
      end

      context &quot;and the signature count is 1 less than the threshold&quot; do
        let(:signature_count) { 9 }

        it &quot;is truthy&quot; do
          expect(petition.at_threshold_for_response?).to be_truthy
        end
      end

      context &quot;and the signature count equal to the threshold&quot; do
        let(:signature_count) { 10 }

        it &quot;is truthy&quot; do
          expect(petition.at_threshold_for_response?).to be_truthy
        end
      end

      context &quot;and the signature count is more than the threshold&quot; do
        let(:signature_count) { 10 }

        it &quot;is truthy&quot; do
          expect(petition.at_threshold_for_response?).to be_truthy
        end
      end
    end

    context &quot;when response_threshold_reached_at is present&quot; do
      let(:petition) { FactoryBot.create(:awaiting_petition) }

      before do
        expect(Site).not_to receive(:threshold_for_response)
      end

      it &quot;is falsey&quot; do
        expect(petition.at_threshold_for_response?).to be_falsey
      end
    end
  end

  describe &#39;at_threshold_for_debate?&#39; do
    let(:petition) { FactoryBot.create(:petition, signature_count: signature_count) }

    context &#39;when signature count is 1 less than the threshold&#39; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1978" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1994" class="js-smell-location">1</a>                  <a href="petition_spec.html#L2002" class="js-smell-location">2</a>                  </div>  </li></ol>
      let(:signature_count) { Site.threshold_for_debate - 1 }

      it &#39;is truthy&#39; do
        expect(petition.at_threshold_for_debate?).to be_truthy
      end
    end

    context &#39;when signature count is equal to the threshold&#39; do
      let(:signature_count) { Site.threshold_for_debate }

      it &#39;is truthy&#39; do
        expect(petition.at_threshold_for_debate?).to be_truthy
      end
    end

    context &#39;when signature count is 1 or more than the threshold&#39; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1978" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1994" class="js-smell-location">1</a>                  <a href="petition_spec.html#L2002" class="js-smell-location">2</a>                  </div>  </li></ol>
      let(:signature_count) { Site.threshold_for_debate + 1 }

      it &#39;is truthy&#39; do
        expect(petition.at_threshold_for_debate?).to be_truthy
      end
    end

    context &#39;when signature count is 2 or more less than the threshold&#39; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L1978" class="js-smell-location">0</a>                  <a href="petition_spec.html#L1994" class="js-smell-location">1</a>                  <a href="petition_spec.html#L2002" class="js-smell-location">2</a>                  </div>  </li></ol>
      let(:signature_count) { Site.threshold_for_debate - 2 }

      it &#39;is falsey&#39; do
        expect(petition.at_threshold_for_debate?).to be_falsey
      end
    end

    context &#39;when the debate_threshold_reached_at is present&#39; do
      let(:petition) { FactoryBot.create(:awaiting_debate_petition) }

      it &#39;is falsey&#39; do
        expect(petition.at_threshold_for_debate?).to be_falsey
      end
    end
  end

  describe &#39;#publish&#39; do
    subject(:petition) { FactoryBot.create(:petition) }
    let(:now) { Time.current }
    let(:duration) { Site.petition_duration.months }
    let(:closing_date) { (now + duration).end_of_day }

    before do
      petition.publish
    end

    it &quot;sets the state to OPEN&quot; do
      expect(petition.state).to eq(Petition::OPEN_STATE)
    end

    it &quot;sets the open date to now&quot; do
      expect(petition.open_at).to be_within(1.second).of(now)
    end
  end

  describe &quot;#reject&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe##reject has a flog score of 59</span>          </div>  </li></ol>
    subject(:petition) { FactoryBot.create(:petition) }

    (Rejection::CODES - Rejection::HIDDEN_CODES).each do |rejection_code|
      context &quot;when the reason for rejection is #{rejection_code}&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L2042" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2059" class="js-smell-location">1</a>                  </div>  </li></ol>
        before do
          petition.reject(code: rejection_code)
          petition.reload
        end

        it &quot;sets rejection.code to &#39;#{rejection_code}&#39;&quot; do
          expect(petition.rejection.code).to eq(rejection_code)
        end

        it &quot;sets Petition#state to &#39;rejected&#39;&quot; do
          expect(petition.state).to eq(&quot;rejected&quot;)
        end
      end
    end

    Rejection::HIDDEN_CODES.each do |rejection_code|
      context &quot;when the reason for rejection is #{rejection_code}&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L2042" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2059" class="js-smell-location">1</a>                  </div>  </li></ol>
        before do
          petition.reject(code: rejection_code)
          petition.reload
        end

        it &quot;sets rejection.code to &#39;#{rejection_code}&#39;&quot; do
          expect(petition.rejection.code).to eq(rejection_code)
        end

        it &quot;sets Petition#state to &#39;hidden&#39;&quot; do
          expect(petition.state).to eq(&quot;hidden&quot;)
        end
      end
    end

    context &quot;when two moderators reject the petition at the same time&quot; do
      let(:rejection) { petition.reload.rejection }

      it &quot;doesn&#39;t raise an ActiveRecord::RecordNotUnique error&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>VeryHighComplexity</b></a>        </span>      </div>      <span>describe(#reject)::context(when two moderators reject the petition at the same time)::itdoesn't raise an ActiveRecord::RecordNotUnique error has a flog score of 72</span>          </div>  </li></ol>
        expect {
          p1 = described_class.find(petition.id)
          p2 = described_class.find(petition.id)

          expect(p1.rejection).not_to be_persisted
          expect(p1.association(:rejection)).to be_loaded

          expect(p2.rejection).not_to be_persisted
          expect(p2.association(:rejection)).to be_loaded

          p1.reject(code: &quot;duplicate&quot;)
          p2.reject(code: &quot;irrelevant&quot;)

          expect(rejection.code).to eq(&quot;irrelevant&quot;)
        }.not_to raise_error
      end
    end
  end

  describe &#39;#close!&#39; do
    subject(:petition) { FactoryBot.create(:open_petition, debate_state: debate_state) }
    let(:now) { Time.current }
    let(:duration) { Site.petition_duration.months }
    let(:closing_date) { (now + duration).end_of_day }
    let(:debate_state) { &#39;pending&#39; }

    it &quot;sets the state to CLOSED&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L2105" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2160" class="js-smell-location">1</a>                  <a href="petition_spec.html#L2204" class="js-smell-location">2</a>                  </div>  </li></ol>
      expect {
        petition.close!(now)
      }.to change {
        petition.state
      }.from(Petition::OPEN_STATE).to(Petition::CLOSED_STATE)
    end

    it &quot;sets the closing date to now&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L2113" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2168" class="js-smell-location">1</a>                  <a href="petition_spec.html#L2212" class="js-smell-location">2</a>                  </div>  </li></ol>
      expect {
        petition.close!(now)
      }.to change {
        petition.closed_at
      }.from(nil).to(now)
    end

    %w[pending awaiting scheduled debated not_debated].each do |state|
      context &quot;when the debate state is &#39;#{state}&#39;&quot; do
        let(:debate_state) { state }

        it &quot;doesn&#39;t change the debate state&quot; do
          expect {
            petition.close!
          }.not_to change {
            petition.debate_state
          }
        end
      end
    end

    context &quot;when called without an argument&quot; do
      it &quot;sets the closing date to the deadline&quot; do
        expect {
          petition.close!
        }.to change {
          petition.closed_at
        }.from(nil).to(petition.deadline)
      end
    end

    (Petition::STATES - [Petition::OPEN_STATE]).each do |state|
      context &quot;when called on a #{state} petition&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L2146" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2187" class="js-smell-location">1</a>                  </div>  </li></ol>
        subject(:petition) { FactoryBot.create(:&quot;#{state}_petition&quot;) }

        it &quot;raises a RuntimeError&quot; do
          expect { petition.close! }.to raise_error(RuntimeError)
        end
      end
    end
  end

  describe &#39;#stop!&#39; do
    subject(:petition) { FactoryBot.create(:pending_petition) }
    let(:dissolution_at) { 1.day.ago }

    it &quot;sets the state to STOPPED&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L2105" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2160" class="js-smell-location">1</a>                  <a href="petition_spec.html#L2204" class="js-smell-location">2</a>                  </div>  </li></ol>
      expect {
        petition.stop!(dissolution_at)
      }.to change {
        petition.state
      }.from(Petition::PENDING_STATE).to(Petition::STOPPED_STATE)
    end

    it &quot;sets the stopped date to the dissolution time&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L2113" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2168" class="js-smell-location">1</a>                  <a href="petition_spec.html#L2212" class="js-smell-location">2</a>                  </div>  </li></ol>
      expect {
        petition.stop!(dissolution_at)
      }.to change {
        petition.stopped_at
      }.from(nil).to(dissolution_at)
    end

    context &quot;when called without an argument&quot; do
      it &quot;sets the closing date to current time&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 4 nodes</span>              <span>Locations:</span>                  <a href="invalidation_spec.html#L241" class="js-smell-location">0</a>                  <a href="invalidation_spec.html#L301" class="js-smell-location">1</a>                  <a href="invalidation_spec.html#L357" class="js-smell-location">2</a>                  <a href="petition_spec.html#L2177" class="js-smell-location">3</a>                  </div>  </li>  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#stop!)::context(when called without an argument)::it#sets the closing date to current time has a flog score of 27</span>          </div>  </li></ol>
        expect {
          petition.stop!
        }.to change {
          petition.stopped_at
        }.from(nil).to(be_within(1.second).of(Time.current))
      end
    end

    Petition::MODERATED_STATES.each do |state|
      context &quot;when called on a #{state} petition&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L2146" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2187" class="js-smell-location">1</a>                  </div>  </li></ol>
        subject(:petition) { FactoryBot.create(:&quot;#{state}_petition&quot;) }

        it &quot;raises a RuntimeError&quot; do
          expect { petition.stop! }.to raise_error(RuntimeError)
        end
      end
    end

    context &quot;when the creator&#39;s signature is now invalid&quot; do
      let(:creator) { petition.creator }

      before do
        creator.update_column(:email, &quot;jo+123@public.com&quot;)
        creator.reload
      end

      it &quot;sets the state to STOPPED&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L2105" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2160" class="js-smell-location">1</a>                  <a href="petition_spec.html#L2204" class="js-smell-location">2</a>                  </div>  </li></ol>
        expect {
          petition.stop!(dissolution_at)
        }.to change {
          petition.state
        }.from(Petition::PENDING_STATE).to(Petition::STOPPED_STATE)
      end

      it &quot;sets the stopped date to the dissolution time&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L2113" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2168" class="js-smell-location">1</a>                  <a href="petition_spec.html#L2212" class="js-smell-location">2</a>                  </div>  </li></ol>
        expect {
          petition.stop!(dissolution_at)
        }.to change {
          petition.stopped_at
        }.from(nil).to(dissolution_at)
      end
    end
  end

  describe &#39;#flag&#39; do
    subject(:petition) { FactoryBot.create(:petition) }

    before do
      petition.flag
    end

    it &quot;sets the state to FLAGGED&quot; do
      expect(petition.state).to eq(Petition::FLAGGED_STATE)
    end
  end

  describe &#39;#deadline&#39; do
    let(:now) { Time.current }

    context &#39;for closed petitions&#39; do
      let(:closed_at) { now + 1.day }
      subject(:petition) { FactoryBot.build(:closed_petition, closed_at: closed_at) }

      it &#39;returns the closed_at timestamp&#39; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#deadline)::context(for closed petitions)::it#returns the closed_at timestamp has a flog score of 27</span>          </div>  </li></ol>
        expect(petition.closed_at).to eq closed_at
        expect(petition.deadline).to eq petition.closed_at
      end
    end

    context &#39;for open petitions&#39; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#deadline)::context#for open petitions has a flog score of 29</span>          </div>  </li></ol>
      subject(:petition) { FactoryBot.build(:open_petition, open_at: now) }
      let(:duration) { Site.petition_duration.months }
      let(:closing_date) { (now + duration).end_of_day }

      it &quot;returns the end of the day, #{Site.petition_duration} months after the open_at&quot; do
        expect(petition.open_at).to eq now
        expect(petition.deadline).to eq closing_date
      end

      it &quot;prefers any closed_at stamp that has been set&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#deadline)::context(for open petitions)::it#prefers any closed_at stamp that has been set has a flog score of 34</span>          </div>  </li></ol>
        petition.closed_at = now + 1.day
        expect(petition.deadline).not_to eq closing_date
        expect(petition.deadline).to eq petition.closed_at
      end
    end

    context &#39;for petitions in other states without an open_at&#39; do
      subject(:petition) { FactoryBot.build(:petition, open_at: nil) }
      it &#39;is nil&#39; do
        expect(petition.deadline).to be_nil
      end
    end
  end

  describe &quot;#closing_early_for_dissolution?&quot; do
    let(:now) { Time.current }
    let(:duration) { Site.petition_duration.months }
    subject(:petition) { FactoryBot.build(:open_petition, open_at: open_at) }

    context &quot;when the dissolution of parliament has not been announced&quot; do
      let(:open_at) { now - duration + 1.month }

      before do
        allow(Parliament).to receive(:dissolution_announced?).and_return(false)
      end

      it &quot;returns false&quot; do
        expect(subject.closing_early_for_dissolution?).to eq(false)
      end
    end

    context &quot;when the dissolution of parliament has been announced&quot; do
      let(:dissolution_at) { 6.weeks.since(now).end_of_day }

      before do
        allow(Parliament).to receive(:dissolution_announced?).and_return(true)
        allow(Parliament).to receive(:dissolution_at).and_return(dissolution_at)
      end

      context &quot;and the petition is due to close before then&quot; do
        let(:open_at) { now - duration + 1.month }
        let(:closing_date) { (open_at + duration).end_of_day }

        it &quot;returns false&quot; do
          expect(subject.closing_early_for_dissolution?).to eq(false)
        end
      end

      context &quot;and the petition is due to close after then&quot; do
        let(:open_at) { now - duration + 2.months }
        let(:closing_date) { (open_at + duration).end_of_day }

        it &quot;returns true&quot; do
          expect(subject.closing_early_for_dissolution?).to eq(true)
        end
      end
    end
  end

  describe &quot;#validate_creator!&quot; do
    let(:petition) { FactoryBot.create(:pending_petition, attributes) }
    let(:signature) { petition.creator }
    let(:now) { Time.current }

    around do |example|
      perform_enqueued_jobs do
        example.run
      end
    end

    let(:attributes) do
      { created_at: 2.days.ago, updated_at: 2.days.ago }
    end

    it &quot;changes creator signature state to validated&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 3 nodes</span>              <span>Locations:</span>                  <a href="../jobs/email_threshold_reminder_job_spec.html#L35" class="js-smell-location">0</a>                  <a href="../jobs/email_threshold_reminder_job_spec.html#L43" class="js-smell-location">1</a>                  <a href="petition_spec.html#L2332" class="js-smell-location">2</a>                  </div>  </li></ol>
      expect {
        petition.validate_creator!
      }.to change { signature.reload.validated? }.from(false).to(true)
    end

    it &quot;increments the signature count&quot; do
      expect {
        petition.validate_creator!
      }.to change { petition.signature_count }.by(1)
    end

    it &quot;timestamps the petition to say it was updated before now&quot; do
      petition.validate_creator!(now)
      expect(petition.updated_at).to be &lt; Time.current
    end

    it &quot;timestamps the petition to say it was last signed at before now&quot; do
      petition.validate_creator!
      expect(petition.last_signed_at).to be &lt; Time.current
    end
  end

  describe &quot;#id&quot; do
    let(:petition){ FactoryBot.create(:petition) }

    it &quot;is greater than 100000&quot; do
      expect(petition.id).to be &gt;= 100000
    end
  end

  describe &#39;#has_maximum_sponsors?&#39; do
    %w[pending validated sponsored flagged].each do |state|
      let(:petition) { FactoryBot.create(:&quot;#{state}_petition&quot;, sponsor_count: sponor_count, sponsors_signed: sponsors_signed) }

      context &quot;when petition is #{state}&quot; do
        context &quot;and has less than the maximum number of sponsors&quot; do
          let(:sponor_count) { Site.maximum_number_of_sponsors - 1 }
          let(:sponsors_signed) { true }

          it &quot;returns false&quot; do
            expect(petition.has_maximum_sponsors?).to eq(false)
          end
        end

        context &quot;and has the maximum number of sponsors, but none have signed&quot; do
          let(:sponor_count) { Site.maximum_number_of_sponsors }
          let(:sponsors_signed) { false }

          it &quot;returns false&quot; do
            expect(petition.has_maximum_sponsors?).to eq(false)
          end
        end

        context &quot;and has more than the maximum number of sponsors, but none have signed&quot; do
          let(:sponor_count) { Site.maximum_number_of_sponsors + 1 }
          let(:sponsors_signed) { false }

          it &quot;returns false&quot; do
            expect(petition.has_maximum_sponsors?).to eq(false)
          end
        end

        context &quot;and has the maximum number of sponsors and they have signed&quot; do
          let(:sponor_count) { Site.maximum_number_of_sponsors }
          let(:sponsors_signed) { true }

          it &quot;returns true&quot; do
            expect(petition.has_maximum_sponsors?).to eq(true)
          end
        end

        context &quot;and has more than the maximum number of sponsors and they have signed&quot; do
          let(:sponor_count) { Site.maximum_number_of_sponsors + 1 }
          let(:sponsors_signed) { true }

          it &quot;returns true&quot; do
            expect(petition.has_maximum_sponsors?).to eq(true)
          end
        end
      end
    end
  end

  describe &#39;email requested receipts&#39; do
    it { is_expected.to have_one(:email_requested_receipt).dependent(:destroy) }

    describe &#39;#email_requested_receipt!&#39; do
      let(:petition) { FactoryBot.create(:petition) }

      it &#39;returns the existing db object if one exists&#39; do
        existing = petition.create_email_requested_receipt
        expect(petition.email_requested_receipt!).to eq existing
      end

      it &#39;returns a newly created instance if does not already exist&#39; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(email requested receipts)::describe(#email_requested_receipt!)::it#returns a newly created instance if does not already exist has a flog score of 32</span>          </div>  </li></ol>
        instance = petition.email_requested_receipt!
        expect(instance).to be_present
        expect(instance).to be_a(EmailRequestedReceipt)
        expect(instance.petition).to eq petition
        expect(instance.petition).to be_persisted
      end
    end
  end

  describe &#39;#get_email_requested_at_for&#39; do
    let(:petition) { FactoryBot.create(:open_petition) }
    let(:receipt) { petition.email_requested_receipt! }
    let(:the_stored_time) { 6.days.ago }

    it &#39;returns nil when nothing has been stamped for the supplied name&#39; do
      expect(petition.get_email_requested_at_for(&#39;government_response&#39;)).to be_nil
    end

    it &#39;returns the stored timestamp for the supplied name&#39; do
      receipt.update_column(&#39;government_response&#39;, the_stored_time)
      expect(petition.get_email_requested_at_for(&#39;government_response&#39;)).to eq the_stored_time
    end
  end

  describe &#39;#set_email_requested_at_for&#39; do
    let(:petition) { FactoryBot.create(:open_petition) }
    let(:receipt) { petition.email_requested_receipt! }
    let(:the_stored_time) { 6.days.ago }

    it &#39;sets the stored timestamp for the supplied name to the supplied time&#39; do
      petition.set_email_requested_at_for(&#39;government_response&#39;, to: the_stored_time)
      expect(receipt.government_response).to eq the_stored_time
    end

    it &#39;sets the stored timestamp for the supplied name to the current time if none is supplied&#39; do
      travel_to the_stored_time do
        petition.set_email_requested_at_for(&#39;government_response&#39;)
        expect(receipt.government_response).to eq Time.current
      end
    end
  end

  describe &quot;#signatures_to_email_for&quot; do
    let!(:petition) { FactoryBot.create(:petition) }
    let!(:creator) { petition.creator }
    let!(:other_signature) { FactoryBot.create(:validated_signature, petition: petition) }
    let(:petition_timestamp) { 5.days.ago }

    before { petition.set_email_requested_at_for(&#39;government_response&#39;, to: petition_timestamp) }

    it &#39;raises an error if the petition does not have an email requested receipt&#39; do
      petition.email_requested_receipt.destroy &amp;&amp; petition.reload
      expect { petition.signatures_to_email_for(&#39;government_response&#39;) }.to raise_error ArgumentError
    end

    it &#39;raises an error if the petition does not have the requested timestamp in its email requested receipt&#39; do
      petition.email_requested_receipt.update_column(&#39;government_response&#39;, nil)
      expect { petition.signatures_to_email_for(&#39;government_response&#39;) }.to raise_error ArgumentError
    end

    it &quot;does not return those that do not want to be emailed&quot; do
      petition.creator.update_attribute(:notify_by_email, false)
      expect(petition.signatures_to_email_for(&#39;government_response&#39;)).not_to include creator
    end

    it &#39;does not return unvalidated signatures&#39; do
      other_signature.update_column(:state, Signature::PENDING_STATE)
      expect(petition.signatures_to_email_for(&#39;government_response&#39;)).not_to include other_signature
    end

    it &#39;does not return signatures that have a sent timestamp newer than the petitions requested receipt&#39; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L2498" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2508" class="js-smell-location">1</a>                  </div>  </li></ol>
      other_signature.set_email_sent_at_for(&#39;government_response&#39;, to: petition_timestamp + 1.day)
      expect(petition.signatures_to_email_for(&#39;government_response&#39;)).not_to include other_signature
    end

    it &#39;does not return signatures that have a sent timestamp equal to the petitions requested receipt&#39; do
      other_signature.set_email_sent_at_for(&#39;government_response&#39;, to: petition_timestamp)
      expect(petition.signatures_to_email_for(&#39;government_response&#39;)).not_to include other_signature
    end

    it &#39;does return signatures that have a sent timestamp older than the petitions requested receipt&#39; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L2498" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2508" class="js-smell-location">1</a>                  </div>  </li></ol>
      other_signature.set_email_sent_at_for(&#39;government_response&#39;, to: petition_timestamp - 1.day)
      expect(petition.signatures_to_email_for(&#39;government_response&#39;)).to include other_signature
    end

    it &#39;returns signatures that have no sent timestamp, or null for the requested timestamp in their receipt&#39; do
      expect(petition.signatures_to_email_for(&#39;government_response&#39;)).to match_array [creator, other_signature]
    end
  end

  describe &quot;#cache_key&quot; do
    let(:petition) { FactoryBot.create(:petition, last_signed_at: &quot;2016-06-28 00:00:17 UTC&quot;, open_at: &quot;2016-06-28 00:00:07 UTC&quot;) }
    let(:now) { &quot;2016-06-29 00:00:07 UTC&quot;.in_time_zone }

    around do |example|
      travel_to(now) { example.run }
    end

    it &quot;rounds down to the nearest 5 seconds&quot; do
      expect(petition.cache_key).to eq(&quot;petitions/#{petition.id}-20160629000005000000000&quot;)
    end

    it &quot;can use other columns&quot; do
      expect(petition.cache_key(:open_at, :last_signed_at)).to eq(&quot;petitions/#{petition.id}-20160628000015000000000&quot;)
    end
  end

  describe &quot;#fraudulent_domains&quot; do
    let(:petition) { FactoryBot.create(:open_petition) }
    let(:signatures) { double(:signatures) }

    let(:domains) do
      { &quot;foo.com&quot; =&gt; 2, &quot;bar.com&quot; =&gt; 1 }
    end

    before do
      allow(petition).to receive(:signatures).and_return(signatures)
    end

    it &quot;delegates to signatures association and caches the result&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#fraudulent_domains)::it#delegates to signatures association and caches the result has a flog score of 34</span>          </div>  </li></ol>
      expect(signatures).to receive(:fraudulent_domains).once.and_return(domains)
      expect(petition.fraudulent_domains).to eq(&quot;foo.com&quot; =&gt; 2, &quot;bar.com&quot; =&gt; 1)
      expect(petition.fraudulent_domains).to eq(&quot;foo.com&quot; =&gt; 2, &quot;bar.com&quot; =&gt; 1)
    end
  end

  describe &quot;#fraudulent_domains?&quot; do
    let(:petition) { FactoryBot.create(:open_petition) }

    context &quot;when there no fraudulent signatures&quot; do
      it &quot;returns false&quot; do
        expect(petition.fraudulent_domains?).to eq(false)
      end
    end

    context &quot;when there are fraudulent signatures&quot; do
      before do
        FactoryBot.create(:fraudulent_signature, email: &quot;alice@foo.com&quot;, petition: petition)
      end

      it &quot;returns true&quot; do
        expect(petition.fraudulent_domains?).to eq(true)
      end
    end
  end

  describe &quot;#closed_early_due_to_election?&quot; do
    let(:dissolution_at) { &quot;2017-05-03T00:01:00+01:00&quot;.in_time_zone }

    before do
      allow(Parliament).to receive(:dissolution_at).and_return(dissolution_at)
    end

    context &quot;when the petition was not closed early&quot; do
      let(:open_at) { &quot;2016-04-01T12:00:00+01:00&quot;.in_time_zone }
      let(:closed_at) { Site.closed_at_for_opening(open_at) }

      subject do
        FactoryBot.create(:closed_petition, open_at: open_at, closed_at: closed_at)
      end

      it &quot;returns false&quot; do
        expect(subject.closed_early_due_to_election?).to eq(false)
      end
    end

    context &quot;when the petition was closed early for other reasons&quot; do
      let(:open_at) { &quot;2016-11-01T12:00:00+00:00&quot;.in_time_zone }
      let(:closed_at) { &quot;2017-03-03T12:00:00+00:00&quot;.in_time_zone }

      subject do
        FactoryBot.create(:closed_petition, open_at: open_at, closed_at: closed_at)
      end

      it &quot;returns false&quot; do
        expect(subject.closed_early_due_to_election?).to eq(false)
      end
    end

    context &quot;when the petition was closed early because parliament was dissolved&quot; do
      let(:open_at) { &quot;2017-04-01T12:00:00+01:00&quot;.in_time_zone }

      subject do
        FactoryBot.create(:closed_petition, open_at: open_at, closed_at: dissolution_at)
      end

      it &quot;returns true&quot; do
        expect(subject.closed_early_due_to_election?).to eq(true)
      end
    end
  end

  describe &quot;#archiving?&quot; do
    context &quot;when a petition has not started archiving&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 4 nodes</span>              <span>Locations:</span>                  <a href="constituency_spec.html#L267" class="js-smell-location">0</a>                  <a href="parliament_spec.html#L361" class="js-smell-location">1</a>                  <a href="petition_spec.html#L2621" class="js-smell-location">2</a>                  <a href="petition_spec.html#L2665" class="js-smell-location">3</a>                  </div>  </li></ol>
      let(:petition) { FactoryBot.create(:open_petition, archiving_started_at: nil, archived_at: nil) }

      it &quot;returns false&quot; do
        expect(petition.archiving?).to eq(false)
      end
    end

    context &quot;when a petition has started archiving, but not finished&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L2629" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2673" class="js-smell-location">1</a>                  </div>  </li></ol>
      let(:petition) { FactoryBot.create(:open_petition, archiving_started_at: Time.current, archived_at: nil) }

      it &quot;returns true&quot; do
        expect(petition.archiving?).to eq(true)
      end
    end

    context &quot;when a petition has finished archiving&quot; do
      let(:petition) { FactoryBot.create(:open_petition, archiving_started_at: 1.hour.ago, archived_at: Time.current) }

      it &quot;returns false&quot; do
        expect(petition.archiving?).to eq(false)
      end
    end
  end

  describe &quot;#archived?&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition/statistics_spec.html#L38" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2646" class="js-smell-location">1</a>                  </div>  </li></ol>
    context &quot;when a petition has not been copied to the archive&quot; do
      let(:petition) { FactoryBot.create(:open_petition, archived_at: nil) }

      it &quot;returns false&quot; do
        expect(petition.archived?).to eq(false)
      end
    end

    context &quot;when a petition has been copied to the archive&quot; do
      let(:petition) { FactoryBot.create(:open_petition, archived_at: 1.day.ago) }

      it &quot;returns true&quot; do
        expect(petition.archived?).to eq(true)
      end
    end
  end

  describe &quot;#editing_disabled?&quot; do
    context &quot;when a petition has not started archiving&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 4 nodes</span>              <span>Locations:</span>                  <a href="constituency_spec.html#L267" class="js-smell-location">0</a>                  <a href="parliament_spec.html#L361" class="js-smell-location">1</a>                  <a href="petition_spec.html#L2621" class="js-smell-location">2</a>                  <a href="petition_spec.html#L2665" class="js-smell-location">3</a>                  </div>  </li></ol>
      let(:petition) { FactoryBot.create(:open_petition, archiving_started_at: nil, archived_at: nil) }

      it &quot;returns false&quot; do
        expect(petition.editing_disabled?).to eq(false)
      end
    end

    context &quot;when a petition has started archiving, but not finished&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Similar code found in 2 nodes</span>              <span>Locations:</span>                  <a href="petition_spec.html#L2629" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2673" class="js-smell-location">1</a>                  </div>  </li></ol>
      let(:petition) { FactoryBot.create(:open_petition, archiving_started_at: Time.current, archived_at: nil) }

      it &quot;returns true&quot; do
        expect(petition.editing_disabled?).to eq(true)
      end
    end

    context &quot;when a petition has finished archiving&quot; do
      let(:petition) { FactoryBot.create(:open_petition, archiving_started_at: 1.hour.ago, archived_at: Time.current) }

      it &quot;returns true&quot; do
        expect(petition.editing_disabled?).to eq(true)
      end
    end
  end

  describe &quot;#update_lock!&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Identical code found in 2 nodes</span>              <span>Locations:</span>                  <a href="archived/petition_spec.html#L852" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2690" class="js-smell-location">1</a>                  </div>  </li></ol>
    let(:current_user) { FactoryBot.create(:moderator_user) }

    context &quot;when the petition is not locked&quot; do
      let(:petition) { FactoryBot.create(:petition, locked_by: nil, locked_at: nil) }

      it &quot;doesn&#39;t update the locked_by association&quot; do
        expect {
          petition.update_lock!(current_user)
        }.not_to change {
          petition.reload.locked_by
        }
      end

      it &quot;doesn&#39;t update the locked_at timestamp&quot; do
        expect {
          petition.update_lock!(current_user)
        }.not_to change {
          petition.reload.locked_at
        }
      end
    end

    context &quot;when the petition is locked by someone else&quot; do
      let(:other_user) { FactoryBot.create(:moderator_user) }
      let(:petition) { FactoryBot.create(:petition, locked_by: other_user, locked_at: 1.hour.ago) }

      it &quot;doesn&#39;t update the locked_by association&quot; do
        expect {
          petition.update_lock!(current_user)
        }.not_to change {
          petition.reload.locked_by
        }
      end

      it &quot;doesn&#39;t update the locked_at timestamp&quot; do
        expect {
          petition.update_lock!(current_user)
        }.not_to change {
          petition.reload.locked_at
        }
      end
    end

    context &quot;when the petition is locked by the current user&quot; do
      let(:petition) { FactoryBot.create(:petition, locked_by: current_user, locked_at: 1.hour.ago) }

      it &quot;doesn&#39;t update the locked_by association&quot; do
        expect {
          petition.update_lock!(current_user)
        }.not_to change {
          petition.reload.locked_by
        }
      end

      it &quot;updates the locked_at timestamp&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#update_lock!)::context(when the petition is locked by the current user)::it#updates the locked_at timestamp has a flog score of 30</span>          </div>  </li></ol>
        expect {
          petition.update_lock!(current_user)
        }.to change {
          petition.reload.locked_at
        }.to be_within(1.second).of(Time.current)
      end
    end
  end

  describe &quot;#checkout!&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Identical code found in 2 nodes</span>              <span>Locations:</span>                  <a href="archived/petition_spec.html#L917" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2755" class="js-smell-location">1</a>                  </div>  </li></ol>
    let(:current_user) { FactoryBot.create(:moderator_user) }

    context &quot;when the petition is not locked&quot; do
      let(:petition) { FactoryBot.create(:petition, locked_by: nil, locked_at: nil) }

      it &quot;updates the locked_by association&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#checkout!)::context(when the petition is not locked)::it#updates the locked_by association has a flog score of 26</span>          </div>  </li></ol>
        expect {
          petition.checkout!(current_user)
        }.to change {
          petition.reload.locked_by
        }.from(nil).to(current_user)
      end

      it &quot;updates the locked_at timestamp&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#checkout!)::context(when the petition is not locked)::it#updates the locked_at timestamp has a flog score of 33</span>          </div>  </li></ol>
        expect {
          petition.checkout!(current_user)
        }.to change {
          petition.reload.locked_at
        }.from(nil).to(be_within(1.second).of(Time.current))
      end
    end

    context &quot;when the petition is locked by someone else&quot; do
      let(:other_user) { FactoryBot.create(:moderator_user) }
      let(:petition) { FactoryBot.create(:petition, locked_by: other_user, locked_at: 1.hour.ago) }

      it &quot;returns false&quot; do
        expect(petition.checkout!(current_user)).to eq(false)
      end
    end

    context &quot;when the petition is locked by the current user&quot; do
      let(:petition) { FactoryBot.create(:petition, locked_by: current_user, locked_at: 1.hour.ago) }

      it &quot;doesn&#39;t update the locked_by association&quot; do
        expect {
          petition.checkout!(current_user)
        }.not_to change {
          petition.reload.locked_by
        }
      end

      it &quot;updates the locked_at timestamp&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#checkout!)::context(when the petition is locked by the current user)::it#updates the locked_at timestamp has a flog score of 30</span>          </div>  </li></ol>
        expect {
          petition.checkout!(current_user)
        }.to change {
          petition.reload.locked_at
        }.to be_within(1.second).of(Time.current)
      end
    end
  end

  describe &quot;#force_checkout!&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Identical code found in 2 nodes</span>              <span>Locations:</span>                  <a href="archived/petition_spec.html#L970" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2808" class="js-smell-location">1</a>                  </div>  </li></ol>
    let(:current_user) { FactoryBot.create(:moderator_user) }

    context &quot;when the petition is not locked&quot; do
      let(:petition) { FactoryBot.create(:petition, locked_by: nil, locked_at: nil) }

      it &quot;updates the locked_by association&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#force_checkout!)::context(when the petition is not locked)::it#updates the locked_by association has a flog score of 26</span>          </div>  </li></ol>
        expect {
          petition.force_checkout!(current_user)
        }.to change {
          petition.reload.locked_by
        }.from(nil).to(current_user)
      end

      it &quot;updates the locked_at timestamp&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#force_checkout!)::context(when the petition is not locked)::it#updates the locked_at timestamp has a flog score of 33</span>          </div>  </li></ol>
        expect {
          petition.force_checkout!(current_user)
        }.to change {
          petition.reload.locked_at
        }.from(nil).to(be_within(1.second).of(Time.current))
      end
    end

    context &quot;when the petition is locked by someone else&quot; do
      let(:other_user) { FactoryBot.create(:moderator_user) }
      let(:petition) { FactoryBot.create(:petition, locked_by: other_user, locked_at: 1.hour.ago) }

      it &quot;updates the locked_by association&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#force_checkout!)::context(when the petition is locked by someone else)::it#updates the locked_by association has a flog score of 28</span>          </div>  </li></ol>
        expect {
          petition.force_checkout!(current_user)
        }.to change {
          petition.reload.locked_by
        }.from(other_user).to(current_user)
      end

      it &quot;updates the locked_at timestamp&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#force_checkout!)::context(when the petition is locked by someone else)::it#updates the locked_at timestamp has a flog score of 30</span>          </div>  </li></ol>
        expect {
          petition.force_checkout!(current_user)
        }.to change {
          petition.reload.locked_at
        }.to(be_within(1.second).of(Time.current))
      end
    end

    context &quot;when the petition is locked by the current user&quot; do
      let(:petition) { FactoryBot.create(:petition, locked_by: current_user, locked_at: 1.hour.ago) }

      it &quot;doesn&#39;t update the locked_by association&quot; do
        expect {
          petition.force_checkout!(current_user)
        }.not_to change {
          petition.reload.locked_by
        }
      end

      it &quot;updates the locked_at timestamp&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#force_checkout!)::context(when the petition is locked by the current user)::it#updates the locked_at timestamp has a flog score of 30</span>          </div>  </li></ol>
        expect {
          petition.force_checkout!(current_user)
        }.to change {
          petition.reload.locked_at
        }.to be_within(1.second).of(Time.current)
      end
    end
  end

  describe &quot;#release!&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flay/" target="_blank"><b>DuplicateCode</b></a>        </span>      </div>      <span>Identical code found in 2 nodes</span>              <span>Locations:</span>                  <a href="archived/petition_spec.html#L1035" class="js-smell-location">0</a>                  <a href="petition_spec.html#L2873" class="js-smell-location">1</a>                  </div>  </li></ol>
    let(:current_user) { FactoryBot.create(:moderator_user) }

    context &quot;when the petition is not locked&quot; do
      let(:petition) { FactoryBot.create(:petition, locked_by: nil, locked_at: nil) }

      it &quot;doesn&#39;t update the locked_by association&quot; do
        expect {
          petition.release!(current_user)
        }.not_to change {
          petition.reload.locked_by
        }
      end

      it &quot;doesn&#39;t update the locked_at timestamp&quot; do
        expect {
          petition.release!(current_user)
        }.not_to change {
          petition.reload.locked_at
        }
      end
    end

    context &quot;when the petition is locked by someone else&quot; do
      let(:other_user) { FactoryBot.create(:moderator_user) }
      let(:petition) { FactoryBot.create(:petition, locked_by: other_user, locked_at: 1.hour.ago) }

      it &quot;doesn&#39;t update the locked_by association&quot; do
        expect {
          petition.release!(current_user)
        }.not_to change {
          petition.reload.locked_by
        }
      end

      it &quot;doesn&#39;t update the locked_at timestamp&quot; do
        expect {
          petition.release!(current_user)
        }.not_to change {
          petition.reload.locked_at
        }
      end
    end

    context &quot;when the petition is locked by the current user&quot; do
      let(:petition) { FactoryBot.create(:petition, locked_by: current_user, locked_at: 1.hour.ago) }

      it &quot;updates the locked_by association&quot; do<ol class="nocode errors smells">  <li>    <div class="description">      <div class="heading">        <span>          <i class="fa fa-warning" aria-hidden="true"></i>          <a href="http://docs.seattlerb.org/flog/" target="_blank"><b>HighComplexity</b></a>        </span>      </div>      <span>describe(#release!)::context(when the petition is locked by the current user)::it#updates the locked_by association has a flog score of 26</span>          </div>  </li></ol>
        expect {
          petition.release!(current_user)
        }.to change {
          petition.reload.locked_by
        }.from(current_user).to(nil)
      end

      it &quot;updates the locked_at timestamp&quot; do
        expect {
          petition.release!(current_user)
        }.to change {
          petition.reload.locked_at
        }.to be_nil
      end
    end
  end
end
</code>
  </div>
</div>

        </div>
      </div>
    </div>

    <!-- JavaScripts -->
    <script src='../../assets/javascripts/jquery.min.js'></script>
    <script src='../../assets/javascripts/jquery.tablesorter.min.js'></script>
    <script src='../../assets/javascripts/jquery.scrollTo.min.js'></script>
    <script src='../../assets/javascripts/jquery.timeago.js'></script>
    <script src='../../assets/javascripts/highcharts.src-4.0.1.js'></script>
    <script src='../../assets/javascripts/prettify.js'></script>
    <script src='../../assets/javascripts/bootstrap.min.js'></script>
    <script src='../../assets/javascripts/application.js'></script>
    <script src='../../assets/javascripts/jquery.filtertable.min.js'></script>
  </body>
</html>
